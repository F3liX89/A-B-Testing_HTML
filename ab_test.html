<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<!--
    Content Security Policy:
    - script-src: nur das Plotly-CDN + inline-Skripte (n√∂tig f√ºr den Blob-Worker)
    - style-src:  nur Google Fonts + eigene Inline-Styles
    - font-src:   nur Google Fonts
    - connect-src / img-src / object-src: keine externen Verbindungen erlaubt
    Sch√ºtzt gegen XSS-Angriffe, die externe Ressourcen nachladen w√ºrden.
-->
<meta http-equiv="Content-Security-Policy"
      content="default-src 'none';
               script-src 'self' 'unsafe-inline' https://cdn.plot.ly;
               style-src  'self' 'unsafe-inline' https://fonts.googleapis.com;
               font-src   https://fonts.gstatic.com;
               worker-src blob:;
               img-src    data: blob:;">
<title>Bayesian A/B Testing Dashboard</title>
<script defer src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
<!--
    Inter:     Hauptschrift ‚Äì klar, breit, ausgezeichnete Lesbarkeit.
    Fira Code: Zahlen & Monospace-Werte ‚Äì humanistischere Ziffernform,
               klare 0/O-Unterscheidung, angenehm bei Dezimalzahlen.
-->
<link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;500&family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">

<!-- ============================================================
     STYLESHEET
     Aufgeteilt in:
       1. CSS Custom Properties (Design Tokens)
       2. Base & Reset
       3. Layout-Komponenten (.glass, .grid-2, etc.)
       4. Formular-Elemente (Input, Button, Tooltip)
       5. Ergebnis-Komponenten (KPI, CI-Entry, Badge)
       6. Dark Mode Overrides
       7. Animationen
     ============================================================ -->
<style>

/* ----------------------------------------------------------
   1. CSS Custom Properties ‚Äì alle Farben, Abst√§nde, Radii
      an einem zentralen Ort definiert.
      Dark-Mode-Overrides werden im body.dark-Block gesetzt.
   ---------------------------------------------------------- */
:root {
    /* Hintergrund */
    --bg:              #f0f4ff;
    --bg-gradient:     linear-gradient(145deg, #e8eeff 0%, #f5f0ff 50%, #eff8ff 100%);

    /* Glassmorphism-Karten */
    --glass-bg:        rgba(255, 255, 255, 0.62);
    --glass-border:    rgba(255, 255, 255, 0.85);
    --glass-shadow:    0 4px 32px rgba(80, 90, 160, 0.10);

    /* Typografie */
    --text-primary:    #18181b;
    --text-secondary:  #52525b;
    --text-muted:      #a1a1aa;

    /* Akzentfarben */
    --accent:          #5b6cf9;
    --accent-soft:     rgba(91, 108, 249, 0.12);
    --accent-hover:    #4756e8;

    /* Semantische Farben */
    --success:         #22c55e;
    --success-soft:    rgba(34, 197, 94, 0.12);
    --warning:         #f59e0b;
    --warning-soft:    rgba(245, 158, 11, 0.14);
    --danger:          #ef4444;
    --danger-soft:     rgba(239, 68, 68, 0.12);

    /* Varianten-Farben (f√ºr Traces im Chart + Badges) */
    --c0: #5b6cf9;   /* Control  ‚Äì Indigo   */
    --c1: #f97316;   /* Var 1    ‚Äì Orange   */
    --c2: #22c55e;   /* Var 2    ‚Äì Gr√ºn     */
    --c3: #ec4899;   /* Var 3    ‚Äì Pink     */
    --c4: #a855f7;   /* Var 4    ‚Äì Violett  */

    /* Abst√§nde & Radii */
    --radius-sm:   12px;
    --radius-md:   20px;
    --radius-lg:   28px;
    --gap:         28px;
    --pad:         36px;

    /* √úberg√§nge */
    --transition:  all 0.35s cubic-bezier(0.4, 0, 0.2, 1);
}

/* ----------------------------------------------------------
   2. Base & Reset
   ---------------------------------------------------------- */
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

body {
    /*
     * Inter statt DM Sans:
     *  ‚Äì gr√∂√üere x-H√∂he ‚Üí Buchstaben wirken gr√∂√üer bei gleicher Schriftgr√∂√üe
     *  ‚Äì optimiert f√ºr Bildschirme, hervorragendes Hinting
     *  ‚Äì weite Abst√§nde zwischen Zeichen (letter-spacing leicht reduziert)
     */
    font-family: 'Inter', sans-serif;
    font-size: 15.5px;          /* leicht erh√∂ht f√ºr angenehmeres Lesen */
    line-height: 1.65;          /* mehr Zeilenabstand = ruhigeres Schriftbild */
    letter-spacing: -0.01em;    /* Inter wirkt sonst etwas zu weit */
    color: var(--text-primary);
    background: var(--bg-gradient);
    min-height: 100vh;
    padding: 56px 64px 80px;
    transition: var(--transition);
}

/* ----------------------------------------------------------
   3. Layout-Komponenten
   ---------------------------------------------------------- */

/* Seiten-Header */
.page-header {
    display: flex;
    align-items: flex-start;
    justify-content: space-between;
    margin-bottom: 48px;
}

.page-title {
    font-size: 28px;
    font-weight: 600;
    letter-spacing: -0.5px;
    color: var(--text-primary);
}

.page-subtitle {
    font-size: 14px;
    color: var(--text-muted);
    margin-top: 4px;
    font-family: 'Fira Code', monospace;
}

/* Glassmorphism-Karte ‚Äì Basis-Baustein f√ºr alle Panels */
.glass {
    background: var(--glass-bg);
    backdrop-filter: blur(28px);
    -webkit-backdrop-filter: blur(28px);
    border: 1.5px solid var(--glass-border);
    border-radius: var(--radius-lg);
    padding: var(--pad);
    margin-bottom: var(--gap);
    box-shadow: var(--glass-shadow);
    transition: var(--transition);
}

/* Zweispalten-Grid ‚Äì wird f√ºr KPI-Row und CI-Tabelle genutzt */
.grid-2 {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: var(--gap);
}

/* Dreispalten-Grid f√ºr Metriken-√úbersicht */
.grid-3 {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 16px;
    margin-bottom: var(--gap);
}

/* Abschnitt-√úberschrift mit optionaler Beschreibung */
.section-title {
    font-size: 16px;
    font-weight: 600;
    color: var(--text-primary);
    margin-bottom: 20px;
    display: flex;
    align-items: center;
    gap: 8px;
}

/* ----------------------------------------------------------
   4. Formular-Elemente
   ---------------------------------------------------------- */

/* Einzelne Varianten-Zeile */
.variant-row {
    display: flex;
    align-items: center;
    gap: 14px;
    padding: 12px 16px;
    background: rgba(255,255,255,0.5);
    border-radius: var(--radius-md);
    margin-bottom: 10px;
    border: 1.5px solid transparent;
    transition: var(--transition);
}

.variant-row:hover {
    border-color: var(--accent-soft);
}

/* Farbiger Punkt vor dem Label */
.variant-dot {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    flex-shrink: 0;
}

.variant-label {
    width: 100px;
    font-weight: 500;
    font-size: 14px;
    flex-shrink: 0;
}

/* Conversion Rate ‚Äì wird live berechnet und neben den Inputs angezeigt */
.variant-rate {
    font-family: 'Fira Code', monospace;
    font-size: 14px;       /* +1px f√ºr bessere Lesbarkeit der Live-CR */
    color: var(--accent);
    min-width: 54px;
    font-weight: 500;
}

/* Inlinebeschriftung f√ºr Inputs */
.input-group {
    display: flex;
    flex-direction: column;
    gap: 2px;
}

.input-group label {
    font-size: 11px;
    color: var(--text-muted);
    text-transform: uppercase;
    letter-spacing: 0.5px;
    font-weight: 500;
}

input[type="number"] {
    padding: 8px 12px;
    border-radius: var(--radius-sm);
    border: 1.5px solid rgba(0,0,0,0.08);
    background: rgba(255,255,255,0.8);
    color: var(--text-primary);
    font-family: 'Fira Code', monospace;
    font-size: 15px;      /* +1px: Fira Code wirkt bei gleicher Gr√∂√üe etwas kompakter */
    width: 105px;
    outline: none;
    transition: var(--transition);
}

input[type="number"]:focus {
    border-color: var(--accent);
    box-shadow: 0 0 0 3px var(--accent-soft);
}

/* Validierungsfehler ‚Äì wird per JS gesetzt */
input.invalid {
    border-color: var(--danger);
    background: rgba(239, 68, 68, 0.05);
}

/* Fehlermeldung unter einem Input */
.input-error {
    font-size: 12px;
    color: var(--danger);
    margin-top: 2px;
    display: none;
}

.input-error.visible {
    display: block;
}

/* Prim√§r-Button */
.btn {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    background: var(--accent);
    border: none;
    color: white;
    padding: 11px 22px;
    border-radius: var(--radius-sm);
    cursor: pointer;
    font-family: 'Inter', sans-serif;
    font-size: 14px;
    font-weight: 500;
    transition: var(--transition);
}

.btn:hover {
    background: var(--accent-hover);
    transform: translateY(-1px);
    box-shadow: 0 6px 20px rgba(91, 108, 249, 0.30);
}

.btn:active { transform: translateY(0); }

/* Sekund√§rer (geisterartiger) Button */
.btn-ghost {
    background: transparent;
    border: 1.5px solid rgba(0,0,0,0.12);
    color: var(--text-secondary);
}

.btn-ghost:hover {
    background: rgba(0,0,0,0.04);
    box-shadow: none;
    transform: none;
}

/* Kleiner Entfernen-Button in der Varianten-Zeile */
.btn-remove {
    background: transparent;
    border: none;
    color: var(--text-muted);
    cursor: pointer;
    padding: 4px 8px;
    border-radius: 8px;
    font-size: 16px;
    line-height: 1;
    margin-left: auto;
    transition: var(--transition);
}

.btn-remove:hover { color: var(--danger); background: var(--danger-soft); }

/* Dark-Mode Toggle oben rechts */
.toggle-btn {
    background: rgba(255,255,255,0.6);
    border: 1.5px solid var(--glass-border);
    color: var(--text-primary);
    padding: 9px 18px;
    border-radius: var(--radius-sm);
    cursor: pointer;
    font-size: 13px;
    font-family: 'Inter', sans-serif;
    font-weight: 500;
    transition: var(--transition);
    backdrop-filter: blur(10px);
}

.toggle-btn:hover { background: rgba(255,255,255,0.85); }

/* ----------------------------------------------------------
   Tooltip-System
   Nutzung: <span class="tooltip-wrap">Wort<span class="tooltip-box">Erkl√§rung</span></span>
   ---------------------------------------------------------- */
.tooltip-wrap {
    position: relative;
    display: inline-flex;
    align-items: center;
    gap: 4px;
    cursor: help;
}

/* Das ‚ìò-Icon */
.tooltip-icon {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 16px;
    height: 16px;
    border-radius: 50%;
    background: var(--accent-soft);
    color: var(--accent);
    font-size: 10px;
    font-style: normal;
    font-weight: 600;
    flex-shrink: 0;
}

/* Das Tooltip-Popup */
.tooltip-box {
    position: absolute;
    bottom: calc(100% + 8px);
    left: 50%;
    transform: translateX(-50%);
    background: #18181b;
    color: #f4f4f5;
    font-size: 12px;
    font-weight: 400;
    line-height: 1.5;
    padding: 10px 14px;
    border-radius: 10px;
    width: 240px;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.2s ease;
    z-index: 100;
    white-space: normal;
    font-family: 'Inter', sans-serif;
    box-shadow: 0 8px 24px rgba(0,0,0,0.25);
}

.tooltip-wrap:hover .tooltip-box { opacity: 1; }

/* ----------------------------------------------------------
   5. Ergebnis-Komponenten
   ---------------------------------------------------------- */

/* Kleine Metrik-Kachel (Conversion Rate, Besucher etc.) */
.metric-card {
    background: rgba(255,255,255,0.5);
    border-radius: var(--radius-md);
    padding: 18px 20px;
    border: 1.5px solid rgba(255,255,255,0.9);
}

.metric-label {
    font-size: 11px;
    text-transform: uppercase;
    letter-spacing: 0.6px;
    color: var(--text-muted);
    font-weight: 500;
    margin-bottom: 6px;
}

.metric-value {
    font-size: 24px;       /* von 22px: mehr Pr√§senz bei den Haupt-KPIs */
    font-weight: 600;
    font-family: 'Fira Code', monospace;
    color: var(--text-primary);
}

.metric-sub {
    font-size: 13px;       /* von 12px: Sub-Zeile besser lesbar */
    color: var(--text-muted);
    margin-top: 3px;
}

/* Varianten-Badge ‚Äì farbiger Chip mit Label */
.variant-badge {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    padding: 3px 10px;
    border-radius: 20px;
    font-size: 13px;       /* von 12px */
    font-weight: 600;
    font-family: 'Fira Code', monospace;
}

/* Einzel-Zeile in den Ergebnis-Boxen */
.ci-entry {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 14px 18px;
    border-radius: var(--radius-md);
    margin-bottom: 10px;
    background: rgba(255,255,255,0.45);
    border: 1.5px solid rgba(255,255,255,0.7);
    gap: 12px;
    flex-wrap: wrap;
}

.ci-entry:last-of-type { margin-bottom: 0; }

.ci-left {
    display: flex;
    align-items: center;
    gap: 10px;
}

.ci-values {
    display: flex;
    gap: 20px;
    align-items: center;
}

/* Einzelne Kennzahl innerhalb einer ci-values-Gruppe */
.ci-stat {
    text-align: right;
}

.ci-stat-label {
    font-size: 11px;       /* von 10px: Labels besser lesbar */
    text-transform: uppercase;
    letter-spacing: 0.5px;
    color: var(--text-muted);
    font-weight: 500;
}

.ci-stat-value {
    font-family: 'Fira Code', monospace;
    font-size: 16px;       /* von 15px: Hauptkennzahlen in den Tabellen */
    font-weight: 500;
    color: var(--text-primary);
}

/* Uplift-Chip: gr√ºn bei positivem, rot bei negativem Uplift */
.uplift-chip {
    font-family: 'Fira Code', monospace;
    font-size: 13px;       /* von 12px */
    font-weight: 600;
    padding: 3px 9px;
    border-radius: 20px;
}

.uplift-pos { background: var(--success-soft); color: var(--success); }
.uplift-neg { background: var(--danger-soft);  color: var(--danger);  }
.uplift-neu { background: rgba(0,0,0,0.06);    color: var(--text-muted); }

/* Fortschrittsbalken f√ºr Wahrscheinlichkeiten */
.prob-bar-wrap {
    width: 100%;
    height: 6px;
    background: rgba(0,0,0,0.07);
    border-radius: 10px;
    margin-top: 6px;
    overflow: hidden;
}

.prob-bar {
    height: 100%;
    border-radius: 10px;
    transition: width 0.6s cubic-bezier(0.4, 0, 0.2, 1);
}

/* Ergebnis-Entscheidungsbox */
.decision-box {
    border-radius: var(--radius-lg);
    padding: var(--pad);
    margin-bottom: var(--gap);
    font-size: 15px;
    line-height: 1.7;
    border: 2px solid transparent;
}

.decision-box.success {
    background: var(--success-soft);
    border-color: rgba(34, 197, 94, 0.25);
}

.decision-box.warning {
    background: var(--warning-soft);
    border-color: rgba(245, 158, 11, 0.25);
}

.decision-box.danger {
    background: var(--danger-soft);
    border-color: rgba(239, 68, 68, 0.2);
}

.decision-title {
    font-size: 17px;
    font-weight: 600;
    margin-bottom: 12px;
    display: flex;
    align-items: center;
    gap: 8px;
}

/* Spinner w√§hrend der Berechnung (via Web Worker) */
.spinner-overlay {
    display: none;
    align-items: center;
    justify-content: center;
    gap: 12px;
    padding: 16px 0;
    color: var(--text-secondary);
    font-size: 14px;
}

.spinner-overlay.active { display: flex; }

.spinner {
    width: 20px;
    height: 20px;
    border: 2px solid var(--accent-soft);
    border-top-color: var(--accent);
    border-radius: 50%;
    animation: spin 0.8s linear infinite;
}

/* Trennlinie mit Text */
.divider {
    display: flex;
    align-items: center;
    gap: 12px;
    color: var(--text-muted);
    font-size: 12px;
    margin: 8px 0 20px;
}

.divider::before, .divider::after {
    content: '';
    flex: 1;
    height: 1px;
    background: rgba(0,0,0,0.08);
}

/* Meldung f√ºr Validierungsfehler (globale Box) */
.alert {
    padding: 14px 18px;
    border-radius: var(--radius-md);
    font-size: 14px;
    margin-bottom: 16px;
    display: none;
}

.alert.visible { display: block; }
.alert.error   { background: var(--danger-soft); color: var(--danger); }

/* Erkl√§rungstext unter Ergebnis-Panels */
.small-text {
    font-size: 13px;
    color: var(--text-muted);
    margin-top: 18px;
    line-height: 1.6;
    padding-top: 16px;
    border-top: 1px solid rgba(0,0,0,0.06);
}

/* ----------------------------------------------------------
   6. Dark Mode Overrides
   ---------------------------------------------------------- */
body.dark {
    --bg-gradient:   linear-gradient(145deg, #0f1117 0%, #161822 50%, #111520 100%);
    --glass-bg:      rgba(28, 30, 42, 0.75);
    --glass-border:  rgba(255, 255, 255, 0.08);
    --glass-shadow:  0 4px 32px rgba(0, 0, 0, 0.40);
    --text-primary:  #f4f4f5;
    --text-secondary:#a1a1aa;
    --text-muted:    #52525b;
    --accent-soft:   rgba(91, 108, 249, 0.18);
}

body.dark input[type="number"] {
    background: rgba(255,255,255,0.06);
    border-color: rgba(255,255,255,0.10);
    color: var(--text-primary);
}

body.dark .variant-row     { background: rgba(255,255,255,0.04); }
body.dark .metric-card     { background: rgba(255,255,255,0.04); border-color: rgba(255,255,255,0.06); }
body.dark .ci-entry        { background: rgba(255,255,255,0.04); border-color: rgba(255,255,255,0.07); }
body.dark .toggle-btn      { background: rgba(255,255,255,0.08); border-color: rgba(255,255,255,0.12); color: var(--text-primary); }
body.dark .btn-ghost       { border-color: rgba(255,255,255,0.15); color: var(--text-secondary); }
body.dark .btn-ghost:hover { background: rgba(255,255,255,0.06); }
body.dark .divider::before,
body.dark .divider::after  { background: rgba(255,255,255,0.08); }
body.dark .small-text      { border-color: rgba(255,255,255,0.08); }

/* ----------------------------------------------------------
   ANALYSE-BOXEN-SYSTEM
   Jede Analyse-Box ist ein eigenst√§ndiger .glass-Container
   mit einem editierbaren Titel und derselben Varianten-Struktur
   wie die Haupt-Box. Die erste Box ("Gesamt") ist nicht l√∂schbar.
   ---------------------------------------------------------- */

/* Wrapper um alle Analyse-Boxen */
#analysis-boxes {
    display: flex;
    flex-direction: column;
    gap: var(--gap);
}

/* Jede Analyse-Box */
.analysis-box {
    background: var(--glass-bg);
    backdrop-filter: blur(28px);
    -webkit-backdrop-filter: blur(28px);
    border: 1.5px solid var(--glass-border);
    border-radius: var(--radius-lg);
    padding: var(--pad);
    box-shadow: var(--glass-shadow);
    transition: var(--transition);
}

/* Header-Zeile der Box: Titel links, Entfernen-Button rechts */
.analysis-box-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 20px;
    gap: 12px;
}

/* Editierbarer Box-Titel (z. B. "Gesamt", "Elektronik") */
.inp-box-title {
    font-size: 17px;
    font-weight: 600;
    font-family: 'Inter', sans-serif;
    color: var(--text-primary);
    background: transparent;
    border: 1.5px solid transparent;
    border-radius: 8px;
    padding: 4px 10px;
    outline: none;
    transition: var(--transition);
    min-width: 160px;
    flex: 1;
    max-width: 400px;
}

.inp-box-title:hover:not(:focus) {
    border-color: rgba(0,0,0,0.12);
    background: rgba(255,255,255,0.5);
}

.inp-box-title:focus {
    border-color: var(--accent);
    background: rgba(255,255,255,0.85);
    box-shadow: 0 0 0 3px var(--accent-soft);
}

body.dark .inp-box-title:hover:not(:focus) {
    border-color: rgba(255,255,255,0.15);
    background: rgba(255,255,255,0.05);
}
body.dark .inp-box-title:focus {
    background: rgba(255,255,255,0.08);
}

/* Kleines Label "Segment" oder "Gesamt" neben dem Titel */
.box-type-badge {
    font-size: 11px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.6px;
    padding: 3px 9px;
    border-radius: 20px;
    flex-shrink: 0;
}

.box-type-badge.main    { background: var(--accent-soft); color: var(--accent); }
.box-type-badge.segment { background: rgba(245,158,11,0.12); color: var(--warning); }

/* Entfernen-Button f√ºr Analyse-Boxen */
.btn-remove-box {
    background: transparent;
    border: 1.5px solid rgba(0,0,0,0.10);
    color: var(--text-muted);
    cursor: pointer;
    padding: 6px 12px;
    border-radius: 10px;
    font-size: 13px;
    font-family: 'Inter', sans-serif;
    font-weight: 500;
    transition: var(--transition);
    flex-shrink: 0;
}

.btn-remove-box:hover {
    border-color: var(--danger);
    color: var(--danger);
    background: var(--danger-soft);
}

body.dark .btn-remove-box { border-color: rgba(255,255,255,0.12); }

/* ----------------------------------------------------------
   VARIANTEN-NAME ‚Äì Inline-Textfeld
   Das Label ist kein statischer <span> mehr, sondern ein
   editierbares Input-Feld. Es sieht wie Text aus, bis der
   Nutzer hineinklickt.
   ---------------------------------------------------------- */
.inp-name {
    width: 130px;
    font-size: 14px;
    font-weight: 600;
    font-family: 'Inter', sans-serif;
    color: var(--text-primary);
    background: transparent;
    border: 1.5px solid transparent;
    border-radius: 8px;
    padding: 4px 8px;
    outline: none;
    transition: var(--transition);
    cursor: text;
    flex-shrink: 0;
}

/* Im Fokus: sichtbarer Rahmen ‚Üí zeigt an, dass es editierbar ist */
.inp-name:focus {
    border-color: var(--accent);
    background: rgba(255,255,255,0.85);
    box-shadow: 0 0 0 3px var(--accent-soft);
}

/* Hover-Hinweis: gestrichelter Rahmen */
.inp-name:hover:not(:focus) {
    border-color: rgba(0,0,0,0.15);
    background: rgba(255,255,255,0.5);
}

body.dark .inp-name:focus    { background: rgba(255,255,255,0.08); }
body.dark .inp-name:hover:not(:focus) { border-color: rgba(255,255,255,0.15); }

/* ----------------------------------------------------------
   SEGMENT-SYSTEM
   Jede Variante kann N benannte Segmente haben (z. B.
   Produktgruppen). Segmente werden unterhalb der Haupt-Zeile
   einer Variante in einer ausklappbaren Area angezeigt.
   ---------------------------------------------------------- */

/* Container f√ºr alle Segmente einer Variante */
.segment-area {
    margin-top: 8px;
    padding: 12px 16px 12px 36px; /* Links einger√ºckt (unter dem Dot) */
    background: rgba(0,0,0,0.025);
    border-radius: var(--radius-md);
    border: 1.5px dashed rgba(0,0,0,0.08);
    display: none; /* standardm√§√üig eingeklappt */
}

.segment-area.open { display: block; }

body.dark .segment-area {
    background: rgba(255,255,255,0.03);
    border-color: rgba(255,255,255,0.08);
}

/* √úberschrift der Segment-Area */
.segment-area-title {
    font-size: 11px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.7px;
    color: var(--text-muted);
    margin-bottom: 10px;
}

/* Einzelne Segment-Zeile */
.segment-row {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 8px;
    flex-wrap: wrap;
}

.segment-row:last-of-type { margin-bottom: 0; }

/* Name des Segments (z. B. "Elektronik") */
.inp-segment-name {
    width: 140px;
    font-size: 13px;
    font-family: 'Inter', sans-serif;
    color: var(--text-primary);
    background: rgba(255,255,255,0.75);
    border: 1.5px solid rgba(0,0,0,0.08);
    border-radius: 8px;
    padding: 6px 10px;
    outline: none;
    transition: var(--transition);
}

.inp-segment-name:focus {
    border-color: var(--accent);
    box-shadow: 0 0 0 3px var(--accent-soft);
}

body.dark .inp-segment-name {
    background: rgba(255,255,255,0.06);
    border-color: rgba(255,255,255,0.1);
    color: var(--text-primary);
}

/* Kleiner Entfernen-Button f√ºr einzelne Segment-Zeile */
.btn-remove-seg {
    background: transparent;
    border: none;
    color: var(--text-muted);
    cursor: pointer;
    padding: 3px 6px;
    border-radius: 6px;
    font-size: 13px;
    transition: var(--transition);
}

.btn-remove-seg:hover { color: var(--danger); background: var(--danger-soft); }

/* Toggle-Button zum Auf-/Zuklappen der Segment-Area */
.btn-toggle-seg {
    background: transparent;
    border: 1.5px solid rgba(0,0,0,0.10);
    color: var(--text-muted);
    cursor: pointer;
    padding: 4px 10px;
    border-radius: 8px;
    font-size: 12px;
    font-family: 'Inter', sans-serif;
    font-weight: 500;
    transition: var(--transition);
    margin-left: auto; /* rechtsb√ºndig in der Varianten-Zeile */
}

.btn-toggle-seg:hover  { border-color: var(--accent); color: var(--accent); }
body.dark .btn-toggle-seg { border-color: rgba(255,255,255,0.12); }

/* Live-CR-Anzeige f√ºr einzelne Segment-Zeile */
.segment-rate {
    font-family: 'Fira Code', monospace;
    font-size: 12px;
    color: var(--accent);
    min-width: 48px;
    font-weight: 500;
}

/* ----------------------------------------------------------
   ERGEBNIS-TABS ‚Äì Tab-Navigation
   Ein Tab pro Analyse-Box. Aktiver Tab hervorgehoben.
   ---------------------------------------------------------- */
.tab-bar {
    display: flex;
    gap: 6px;
    flex-wrap: wrap;
    margin-bottom: 24px;
    padding-bottom: 16px;
    border-bottom: 1.5px solid rgba(0,0,0,0.07);
}

body.dark .tab-bar { border-color: rgba(255,255,255,0.08); }

.tab-btn {
    padding: 7px 18px;
    border-radius: 10px;
    border: 1.5px solid rgba(0,0,0,0.10);
    background: transparent;
    color: var(--text-secondary);
    font-size: 13px;
    font-weight: 500;
    font-family: 'Inter', sans-serif;
    cursor: pointer;
    transition: var(--transition);
}

.tab-btn:hover {
    border-color: var(--accent);
    color: var(--accent);
}

.tab-btn.active {
    background: var(--accent);
    border-color: var(--accent);
    color: white;
}

body.dark .tab-btn { border-color: rgba(255,255,255,0.12); }

/* Panel-Inhalte ‚Äì nur aktives Panel sichtbar */
.tab-panel {
    display: none;
}

.tab-panel.active { display: block; }


/* ----------------------------------------------------------
   7. Animationen
   ---------------------------------------------------------- */
@keyframes spin {
    to { transform: rotate(360deg); }
}

@keyframes fadeInUp {
    from { opacity: 0; transform: translateY(16px); }
    to   { opacity: 1; transform: translateY(0);     }
}

/* Ergebnis-Panels erscheinen nacheinander */
.result-panel {
    animation: fadeInUp 0.4s ease both;
}

/* Verz√∂gerung pro Panel ‚Äì wird per data-Attribut angewendet */
.result-panel:nth-child(1) { animation-delay: 0.05s; }
.result-panel:nth-child(2) { animation-delay: 0.12s; }
.result-panel:nth-child(3) { animation-delay: 0.19s; }
.result-panel:nth-child(4) { animation-delay: 0.26s; }
.result-panel:nth-child(5) { animation-delay: 0.33s; }

</style>
</head>

<!-- ============================================================
     HTML-STRUKTUR
     ============================================================ -->
<body class="light">

<!-- ‚îÄ‚îÄ Header ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
<div class="page-header">
    <div>
        <h1 class="page-title">A/B Test Auswertung</h1>
        <p class="page-subtitle">Bayesianische Analyse ¬∑ Beta-Posterior</p>
    </div>
    <button class="toggle-btn" onclick="toggleMode()">üåó Dark Mode</button>
</div>

<!-- ‚îÄ‚îÄ Analyse-Boxen ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
     Jede Box steht f√ºr einen Auswertungskontext (z. B. "Gesamt",
     "Elektronik", "Mobile-Nutzer"). Die erste Box ist nicht
     l√∂schbar. Weitere Boxen werden per Button hinzugef√ºgt.
     ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
<div id="analysis-boxes"></div>

<!-- Button: neue Analyse-Box hinzuf√ºgen -->
<div style="margin-bottom: var(--gap);">
    <button class="btn btn-ghost" onclick="addAnalysisBox()">
        + Segment / Analyse-Box hinzuf√ºgen
    </button>
</div>

<!-- Erweiterte Einstellungen ‚Äì au√üerhalb der Boxen, global -->
<div class="glass" style="margin-bottom: var(--gap);">
    <details>
        <summary style="cursor:pointer; font-weight:500; font-size:14px; color:var(--text-secondary); user-select:none;">
            ‚öôÔ∏è Advanced Settings
        </summary>
        <div style="margin-top:18px; display:flex; gap:24px; flex-wrap:wrap; align-items:flex-end;">
            <div class="input-group">
                <label>Prior Œ± (Alpha)</label>
                <input type="number" id="priorA" value="1" min="0.1" step="0.1">
            </div>
            <div class="input-group">
                <label>Prior Œ≤ (Beta)</label>
                <input type="number" id="priorB" value="1" min="0.1" step="0.1">
            </div>
            <div class="input-group">
                <label>Entscheidungsgrenze (%)</label>
                <input type="number" id="threshold" value="95" min="50" max="100" step="1">
            </div>
            <div class="input-group">
                <label>Credible Interval (%)</label>
                <input type="number" id="ciLevel" value="95" min="50" max="99" step="1">
            </div>
            <div class="input-group">
                <label>Simulationen</label>
                <input type="number" id="numSamples" value="10000" min="1000" max="100000" step="1000">
            </div>
        </div>
        <p class="small-text" style="margin-top:12px; border:none; padding:0;">
            Prior Œ±=1, Œ≤=1 entspricht einem uninformativen (gleichm√§√üigen) Prior.
            H√∂here Werte ziehen die Posteriors zur Mitte hin (Regularisierung).
        </p>
    </details>
</div>

<!-- ‚îÄ‚îÄ Globale Fehlermeldung ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
<div id="validationAlert" class="alert error" style="margin-bottom: var(--gap);"></div>

<!-- ‚îÄ‚îÄ Analyse-Button + Lade-Spinner ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
<div class="glass" style="display:flex; align-items:center; gap:20px; flex-wrap:wrap;">
    <button class="btn" onclick="runTest()">
        ‚ñ∂ Analyse starten
    </button>
    <div class="spinner-overlay" id="spinner">
        <div class="spinner"></div>
        <span>Berechne Posterioren‚Ä¶</span>
    </div>
    <button class="btn btn-ghost" onclick="loadFromURL()" title="Gespeicherte Konfiguration laden">
        üîó URL laden
    </button>
    <!-- Share-Button ‚Äì erst nach einer Analyse sichtbar -->
    <button class="btn btn-ghost" id="shareBtn" onclick="shareURL()" style="display:none;">
        üîó Ergebnisse teilen
    </button>
</div>

<!-- ‚îÄ‚îÄ Ergebnis-Container (wird per JS bef√ºllt) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
<div id="results"></div>


<!-- ============================================================
     JAVASCRIPT
     Aufgeteilt in Sektionen:
       A. Konstanten & State
       B. Dark Mode & Initialisierung
       C. Varianten-Verwaltung
       D. Input-Validierung
       E. URL-State (Teilen / Laden)
       F. Sampling-Algorithmen (Beta, Gamma, Normal)
       G. Web Worker (Sampling im Hintergrund-Thread)
       H. Statistische Hilfsfunktionen
       I. Analyse-Orchestrierung (runTest)
       J. Render-Funktionen (renderResults + Sub-Renderer)
       K. Export-Funktion (CSV)
     ============================================================ -->
<script>

// ============================================================
// A. KONSTANTEN & STATE
// ============================================================

/**
 * Farbpalette f√ºr bis zu 5 Varianten.
 * Wird in jeder Analyse-Box f√ºr dieselben Varianten-Positionen
 * konsistent verwendet (Control = Indigo, Var 1 = Orange, ‚Ä¶).
 */
const VARIANT_COLORS = ['#5b6cf9', '#f97316', '#22c55e', '#ec4899', '#a855f7'];

/**
 * Globaler State ‚Äì wird nach jeder Analyse bef√ºllt
 * und von CSV-Export und Share-URL genutzt.
 */
let lastResults = null;

/**
 * Laufender Z√§hler f√ºr eindeutige Box-IDs.
 * Wird bei addAnalysisBox() hochgez√§hlt und nie zur√ºckgesetzt,
 * damit IDs auch nach dem Entfernen von Boxen eindeutig bleiben.
 */
let boxCounter = 0;


// ============================================================
// B. DARK MODE & INITIALISIERUNG
// ============================================================

/** Schaltet zwischen Light- und Dark-Mode um. */
function toggleMode() {
    document.body.classList.toggle('dark');
    document.body.classList.toggle('light');
}

/**
 * Beim Seitenstart:
 *  ‚Äì URL-Parameter vorhanden ‚Üí Konfiguration laden
 *  ‚Äì Sonst ‚Üí erste Analyse-Box ("Gesamt") mit zwei Standard-Varianten anlegen
 */
(function init() {
    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.has('v')) {
        loadFromURL();
    } else {
        addAnalysisBox('Gesamt', true); // isMain = true ‚Üí nicht l√∂schbar
    }
})();


// ============================================================
// C. ANALYSE-BOXEN-VERWALTUNG
// ============================================================

/**
 * F√ºgt eine neue Analyse-Box in #analysis-boxes ein.
 *
 * Eine Analyse-Box ist ein eigenst√§ndiger Eingabe-Container mit:
 *  ‚Äì Editierbarem Titel (z. B. "Gesamt", "Elektronik", "Mobile")
 *  ‚Äì Eigenem Varianten-Container (Control + beliebig viele Test-Varianten)
 *  ‚Äì Eigenen "+ Variante"-Button und Entfernen-Button
 *
 * Die erste Box (isMain=true) erh√§lt das Badge "Gesamt" und kann
 * nicht entfernt werden. Weitere Boxen erhalten "Segment".
 *
 * @param {string}  title  - Vorausgef√ºllter Titel
 * @param {boolean} isMain - true ‚Üí nicht l√∂schbar, Badge "Gesamt"
 */
function addAnalysisBox(title = 'Neues Segment', isMain = false) {
    const container = document.getElementById('analysis-boxes');
    const boxId     = ++boxCounter;
    const varId     = `variants-${boxId}`; // eindeutiger Container f√ºr Varianten

    const box = document.createElement('div');
    box.className      = 'analysis-box';
    box.dataset.boxId  = boxId;

    box.innerHTML = `
        <!-- ‚îÄ‚îÄ Box-Header: Titel + Badges + Entfernen-Button ‚îÄ‚îÄ -->
        <div class="analysis-box-header">

            <!--
                Editierbarer Titel der Box.
                Sieht wie eine √úberschrift aus, ist aber ein <input>.
                Der Name wird sp√§ter als Tab-Titel in den Ergebnissen verwendet.
            -->
            <input type="text"
                   class="inp-box-title"
                   value="${escapeHTML(title)}"
                   placeholder="Name des Segments">

            <!-- Badge: "Gesamt" (erste Box) oder "Segment" (weitere Boxen) -->
            <span class="box-type-badge ${isMain ? 'main' : 'segment'}">
                ${isMain ? 'Gesamt' : 'Segment'}
            </span>

            <!-- Entfernen-Button (nur bei Nicht-Haupt-Boxen) -->
            ${!isMain
                ? `<button class="btn-remove-box"
                           onclick="this.closest('.analysis-box').remove()"
                           title="Diese Analyse-Box entfernen">
                       ‚úï Entfernen
                   </button>`
                : ''
            }
        </div>

        <!-- ‚îÄ‚îÄ Varianten-Container ‚îÄ‚îÄ -->
        <div id="${varId}"></div>

        <!-- ‚îÄ‚îÄ Aktions-Button: Variante hinzuf√ºgen ‚îÄ‚îÄ -->
        <div style="margin-top:14px;">
            <button class="btn btn-ghost"
                    style="font-size:13px;"
                    onclick="addVariantToBox('${varId}')">
                + Variante hinzuf√ºgen
            </button>
        </div>
    `;

    container.appendChild(box);

    // Standard: Control + erste Test-Variante vorausf√ºllen
    addVariantToBox(varId, true,  1000, 100); // Control
    addVariantToBox(varId, false, 1000, 100); // Variante 1
}

/**
 * F√ºgt eine Varianten-Zeile in den Varianten-Container einer Box ein.
 *
 * Die Zeile enth√§lt:
 *  ‚Äì Editierbares Namensfeld (.inp-name)
 *  ‚Äì Besucher- und Conversions-Inputs
 *  ‚Äì Live-CR-Anzeige
 *  ‚Äì Entfernen-Button (nur Nicht-Control)
 *
 * @param {string}  varContainerId - ID des Varianten-Containers der Box
 * @param {boolean} isControl      - true ‚Üí "Control" (nicht l√∂schbar)
 * @param {number}  visitors       - Vorausgef√ºllte Besucher
 * @param {number}  conversions    - Vorausgef√ºllte Conversions
 * @param {string}  name           - Vorausgef√ºllter Name
 */
function addVariantToBox(varContainerId, isControl = false, visitors = 1000, conversions = 100, name = '') {
    const container  = document.getElementById(varContainerId);
    if (!container) return;

    const index      = container.children.length; // 0 = Control, 1+ = Varianten
    const color      = VARIANT_COLORS[index % VARIANT_COLORS.length];
    const defaultName = isControl ? 'Control' : `Variante ${index}`;
    const displayName = name || defaultName;

    // uid: eindeutig pro Varianten-Zeile (f√ºr Rate-ID)
    const uid = `${varContainerId}_${Date.now()}_${index}`;

    const row = document.createElement('div');
    row.className      = 'variant-row';
    row.dataset.uid    = uid;
    row.dataset.color  = color;

    row.innerHTML = `
        <!-- Farbpunkt -->
        <div class="variant-dot" style="background:${color};"></div>

        <!-- Editierbarer Name -->
        <input type="text"
               class="inp-name"
               value="${escapeHTML(displayName)}"
               placeholder="${escapeHTML(defaultName)}"
               title="Namen bearbeiten">

        <!-- Besucher -->
        <div class="input-group">
            <label>Besucher</label>
            <input type="number" class="inp-visitors" value="${visitors}" min="1"
                   oninput="updateRate(this.closest('.variant-row'))">
        </div>

        <!-- Conversions -->
        <div class="input-group">
            <label>Conversions</label>
            <input type="number" class="inp-conversions" value="${conversions}" min="0"
                   oninput="updateRate(this.closest('.variant-row'))">
        </div>

        <!-- Live-CR -->
        <div class="variant-rate" id="rate-${uid}">
            ${(conversions / visitors * 100).toFixed(2)}%
        </div>

        <!-- Entfernen (nur Nicht-Control) -->
        ${!isControl
            ? `<button class="btn-remove"
                       onclick="this.closest('.variant-row').remove()"
                       title="Variante entfernen">‚úï</button>`
            : ''
        }
    `;

    container.appendChild(row);
}

/**
 * Berechnet und zeigt die Live-CR einer Varianten-Zeile an.
 *
 * @param {HTMLElement} row - Die .variant-row
 */
function updateRate(row) {
    const n      = parseFloat(row.querySelector('.inp-visitors').value)    || 0;
    const c      = parseFloat(row.querySelector('.inp-conversions').value)  || 0;
    const uid    = row.dataset.uid;
    const rateEl = document.getElementById(`rate-${uid}`);
    if (rateEl) {
        rateEl.textContent = n > 0 ? `${(c / n * 100).toFixed(2)}%` : '‚Äì';
    }
}


// ============================================================
// D. INPUT-VALIDIERUNG
// ============================================================

/**
 * Liest alle Analyse-Boxen und ihre Varianten-Zeilen aus,
 * validiert die Eingaben und gibt ein Array von Analyse-Objekten zur√ºck.
 *
 * R√ºckgabe-Struktur:
 * {
 *   valid: boolean,
 *   analyses?: Array<{
 *     title:    string,       // Titel der Box (z. B. "Gesamt", "Elektronik")
 *     isMain:   boolean,      // true = erste Box
 *     variants: Array<{
 *       label, n, c, color, alpha, beta
 *     }>
 *   }>,
 *   error?: string
 * }
 *
 * M√∂gliche Validierungsfehler:
 *  ‚Äì Weniger als 2 Varianten in einer Box
 *  ‚Äì Conversions > Besucher
 *  ‚Äì Negative oder leere Werte
 */
function parseAndValidate() {
    const boxes  = document.querySelectorAll('.analysis-box');
    const priorA = Math.max(0.1, parseFloat(document.getElementById('priorA').value) || 1);
    const priorB = Math.max(0.1, parseFloat(document.getElementById('priorB').value) || 1);

    if (boxes.length < 1) {
        return { valid: false, error: 'Bitte mindestens eine Analyse-Box bef√ºllen.' };
    }

    const analyses = [];
    let errorMsg   = '';

    boxes.forEach((box, boxIdx) => {
        if (errorMsg) return; // Abbrechen bei erstem Fehler

        // Titel der Box lesen
        const titleInput = box.querySelector('.inp-box-title');
        const title      = (titleInput && titleInput.value.trim()) ||
                           (boxIdx === 0 ? 'Gesamt' : `Segment ${boxIdx}`);
        const isMain     = boxIdx === 0;

        // Alle Varianten-Zeilen dieser Box
        const rows    = box.querySelectorAll('.variant-row');
        const variants = [];

        if (rows.length < 2) {
            errorMsg = `"${title}": Bitte mindestens 2 Varianten (Control + eine Test-Variante) eingeben.`;
            return;
        }

        rows.forEach((row, i) => {
            if (errorMsg) return;

            const nInput    = row.querySelector('.inp-visitors');
            const cInput    = row.querySelector('.inp-conversions');
            const nameInput = row.querySelector('.inp-name');
            const n         = parseInt(nInput.value, 10);
            const c         = parseInt(cInput.value, 10);

            // Custom-Name mit Fallback
            const defaultLabel = i === 0 ? 'Control' : `Variante ${i}`;
            const label        = (nameInput && nameInput.value.trim()) || defaultLabel;

            // Validierung
            nInput.classList.remove('invalid');
            cInput.classList.remove('invalid');

            if (isNaN(n) || n < 1) {
                nInput.classList.add('invalid');
                errorMsg = `"${title}" ‚Ä∫ ${label}: Besucher muss mindestens 1 sein.`;
                return;
            } else if (isNaN(c) || c < 0) {
                cInput.classList.add('invalid');
                errorMsg = `"${title}" ‚Ä∫ ${label}: Conversions darf nicht negativ sein.`;
                return;
            } else if (c > n) {
                cInput.classList.add('invalid');
                errorMsg = `"${title}" ‚Ä∫ ${label}: Conversions (${c}) > Besucher (${n}).`;
                return;
            }

            variants.push({
                label,
                n,
                c,
                color: VARIANT_COLORS[i % VARIANT_COLORS.length],
                // Posterior-Parameter: Prior + beobachtete Daten
                alpha: priorA + c,
                beta:  priorB + n - c
            });
        });

        if (!errorMsg) {
            analyses.push({ title, isMain, variants });
        }
    });

    if (errorMsg) return { valid: false, error: errorMsg };
    return { valid: true, analyses };
}

/** Zeigt oder versteckt die globale Fehler-Alert-Box. */
function showAlert(msg) {
    const el = document.getElementById('validationAlert');
    el.textContent = msg;
    el.classList.toggle('visible', !!msg);
}


// ============================================================
// E. URL-STATE (TEILEN / LADEN)
// ============================================================

/**
 * Serialisiert alle Analyse-Boxen in die URL.
 *
 * Format: ?boxes=title~varName|n,c;varName|n,c&boxes=...&pa=1&...
 * Jede Box ist ein eigener "boxes"-Parameter.
 * Varianten innerhalb einer Box sind durch ";" getrennt.
 * Format einer Variante: "encodedName|visitors,conversions"
 */
function shareURL() {
    const boxes  = document.querySelectorAll('.analysis-box');
    const params = new URLSearchParams();

    boxes.forEach(box => {
        const title = box.querySelector('.inp-box-title')?.value || '';
        const rows  = box.querySelectorAll('.variant-row');
        const varParts = [];

        rows.forEach(row => {
            const name = encodeURIComponent(row.querySelector('.inp-name')?.value || '');
            const n    = row.querySelector('.inp-visitors').value;
            const c    = row.querySelector('.inp-conversions').value;
            varParts.push(`${name}|${n},${c}`);
        });

        params.append('box', `${encodeURIComponent(title)}~${varParts.join(';')}`);
    });

    params.set('pa',  document.getElementById('priorA').value);
    params.set('pb',  document.getElementById('priorB').value);
    params.set('thr', document.getElementById('threshold').value);
    params.set('ci',  document.getElementById('ciLevel').value);

    const url = `${location.origin}${location.pathname}?${params}`;
    navigator.clipboard.writeText(url)
        .then(() => alert('Link in die Zwischenablage kopiert!'))
        .catch(() => prompt('Link kopieren:', url));
}

/**
 * Liest URL-Parameter ein und baut die Analyse-Boxen neu auf.
 * Versteht das neue Mehrfach-Box-Format.
 */
function loadFromURL() {
    const p = new URLSearchParams(window.location.search);
    if (!p.has('box')) { showAlert('Keine g√ºltigen URL-Parameter gefunden.'); return; }

    // Bestehende Boxen entfernen
    document.getElementById('analysis-boxes').innerHTML = '';
    boxCounter = 0;

    const boxStrings = p.getAll('box');
    boxStrings.forEach((boxStr, bi) => {
        const tildeIdx = boxStr.indexOf('~');
        const title    = decodeURIComponent(boxStr.slice(0, tildeIdx));
        const varStr   = boxStr.slice(tildeIdx + 1);

        addAnalysisBox(title, bi === 0);

        // Varianten-Container der zuletzt hinzugef√ºgten Box
        const boxes    = document.querySelectorAll('.analysis-box');
        const lastBox  = boxes[boxes.length - 1];
        const varCont  = lastBox.querySelector('[id^="variants-"]');
        if (!varCont) return;

        // Standard-Varianten entfernen (addAnalysisBox hat schon 2 angelegt)
        varCont.innerHTML = '';

        const varParts = varStr.split(';');
        varParts.forEach((vPart, vi) => {
            const pipeIdx = vPart.indexOf('|');
            const vName   = pipeIdx >= 0 ? decodeURIComponent(vPart.slice(0, pipeIdx)) : '';
            const rest    = pipeIdx >= 0 ? vPart.slice(pipeIdx + 1) : vPart;
            const [vN, vC] = rest.split(',').map(Number);
            addVariantToBox(varCont.id, vi === 0, vN || 1000, vC || 100, vName);
        });
    });

    if (p.has('pa'))  document.getElementById('priorA').value    = p.get('pa');
    if (p.has('pb'))  document.getElementById('priorB').value    = p.get('pb');
    if (p.has('thr')) document.getElementById('threshold').value = p.get('thr');
    if (p.has('ci'))  document.getElementById('ciLevel').value   = p.get('ci');
}


// ============================================================
// F. SAMPLING-ALGORITHMEN
// ============================================================

/**
 * Box-Muller-Transformation: liefert eine standard-normalverteilte Zufallszahl.
 * Wird f√ºr die Gamma-Approximation ben√∂tigt.
 */
function normalSample() {
    let u = 0, v = 0;
    while (u === 0) u = Math.random();
    while (v === 0) v = Math.random();
    return Math.sqrt(-2 * Math.log(u)) * Math.cos(2 * Math.PI * v);
}

/**
 * Marsaglia-Tsang-Algorithmus f√ºr Gamma(s, 1)-Samples.
 * Ben√∂tigt s > 1; f√ºr s < 1 wird ein Trick angewendet (siehe betaSample).
 *
 * @param {number} s - Shape-Parameter
 * @returns {number}
 */
function gammaSample(s) {
    if (s < 1) {
        // F√ºr s < 1: Gamma(s) = Gamma(s+1) * U^(1/s)
        return gammaSample(s + 1) * Math.pow(Math.random(), 1 / s);
    }
    const d = s - 1 / 3;
    const c = 1 / Math.sqrt(9 * d);
    while (true) {
        let x = normalSample();
        let v = Math.pow(1 + c * x, 3);
        if (v > 0) {
            const u = Math.random();
            if (u < 1 - 0.0331 * Math.pow(x, 4) ||
                Math.log(u) < 0.5 * x * x + d * (1 - v + Math.log(v))) {
                return d * v;
            }
        }
    }
}

/**
 * Zieht einen Beta(a, b)-Sample √ºber zwei Gamma-Samples.
 * Beta(a,b) = Gamma(a) / (Gamma(a) + Gamma(b))
 *
 * @param {number} a - Alpha-Parameter
 * @param {number} b - Beta-Parameter
 * @returns {number} - Wert in [0, 1]
 */
function betaSample(a, b) {
    const x = gammaSample(a);
    const y = gammaSample(b);
    return x / (x + y);
}


// ============================================================
// G. WEB WORKER (Sampling im Hintergrund-Thread)
// ============================================================

/**
 * F√ºhrt das Beta-Sampling f√ºr alle Varianten in einem Web Worker aus,
 * damit der UI-Thread nicht blockiert wird (kein "Freezing" des Browsers).
 *
 * Technik: Der Worker-Code wird als Blob-URL erzeugt (kein separates .js-File n√∂tig).
 *
 * @param {Array}  variants   - Array von { alpha, beta, label }
 * @param {number} numSamples - Anzahl der Monte-Carlo-Draws
 * @returns {Promise<Float32Array[]>} - Array von Posterior-Sample-Arrays
 */
function samplePosteriorsInWorker(variants, numSamples) {
    return new Promise((resolve, reject) => {

        // Worker-Code als String ‚Äì enth√§lt die Sampling-Funktionen und die Haupt-Logik
        const workerCode = `
            // --- Sampling-Funktionen (Kopie aus dem Haupt-Thread) ---
            function normalSample() {
                let u = 0, v = 0;
                while (u === 0) u = Math.random();
                while (v === 0) v = Math.random();
                return Math.sqrt(-2 * Math.log(u)) * Math.cos(2 * Math.PI * v);
            }
            function gammaSample(s) {
                if (s < 1) return gammaSample(s + 1) * Math.pow(Math.random(), 1 / s);
                const d = s - 1/3, c = 1 / Math.sqrt(9 * d);
                while (true) {
                    let x = normalSample(), v = Math.pow(1 + c * x, 3);
                    if (v > 0) {
                        const u = Math.random();
                        if (u < 1 - 0.0331 * x**4 || Math.log(u) < 0.5 * x*x + d*(1 - v + Math.log(v)))
                            return d * v;
                    }
                }
            }
            function betaSample(a, b) {
                const x = gammaSample(a), y = gammaSample(b);
                return x / (x + y);
            }

            // --- Hauptlogik des Workers ---
            self.onmessage = function(e) {
                const { variants, numSamples } = e.data;

                // F√ºr jede Variante ein Float32Array mit numSamples Draws
                const posteriors = variants.map(v => {
                    const arr = new Float32Array(numSamples);
                    for (let i = 0; i < numSamples; i++) {
                        arr[i] = betaSample(v.alpha, v.beta);
                    }
                    return arr;
                });

                // Ergebnis zur√ºck an den Haupt-Thread senden
                // Transferable Objects vermeiden Kopier-Overhead f√ºr gro√üe Arrays
                self.postMessage(
                    { posteriors },
                    posteriors.map(p => p.buffer)
                );
            };
        `;

        // Worker via Blob-URL starten
        const blob      = new Blob([workerCode], { type: 'application/javascript' });
        const workerURL = URL.createObjectURL(blob);
        const worker    = new Worker(workerURL);

        worker.onmessage = (e) => {
            URL.revokeObjectURL(workerURL); // Speicher freigeben
            resolve(e.data.posteriors);
        };

        worker.onerror = (err) => {
            URL.revokeObjectURL(workerURL);
            reject(err);
        };

        worker.postMessage({ variants, numSamples });
    });
}


// ============================================================
// H. STATISTISCHE HILFSFUNKTIONEN
// ============================================================

/**
 * Berechnet ein Quantil eines Float32Array.
 * Sortiert das Array einmalig ‚Äì f√ºr mehrere Quantile effizienter
 * als mehrfach zu sortieren.
 *
 * @param {Float32Array} arr - Sample-Array
 * @param {number}       p   - Quantil in [0, 1]
 * @returns {number}
 */
function quantile(arr, p) {
    const sorted = Float32Array.from(arr).sort();
    const idx    = Math.min(Math.floor(p * sorted.length), sorted.length - 1);
    return sorted[idx];
}

/**
 * Berechnet das Highest Density Interval (HDI) ‚Äì den schmalsten
 * Bereich, der (1-alpha)% der Posterior-Masse enth√§lt.
 *
 * Algorithmus: Sliding-Window √ºber sortiertes Array.
 *
 * @param {Float32Array} arr      - Sample-Array
 * @param {number}       credMass - Anteil in [0, 1], z. B. 0.95
 * @returns {{ lower: number, upper: number }}
 */
function hdi(arr, credMass) {
    const sorted    = Array.from(arr).sort((a, b) => a - b);
    const n         = sorted.length;
    const width     = Math.floor(credMass * n); // Anzahl Samples im Intervall
    let minWidth    = Infinity;
    let lowerIdx    = 0;

    // Engsten Window suchen, der genug Samples enth√§lt
    for (let i = 0; i <= n - width; i++) {
        const intervalWidth = sorted[i + width - 1] - sorted[i];
        if (intervalWidth < minWidth) {
            minWidth = intervalWidth;
            lowerIdx = i;
        }
    }

    return {
        lower: sorted[lowerIdx],
        upper: sorted[lowerIdx + width - 1]
    };
}

/**
 * Kernel Density Estimator (KDE) mit Gauss-Kernel.
 * Transformiert ein Sample-Array in eine glatte Dichtefunktion.
 *
 * @param {number[]} sample    - Datenpunkte (in Prozent)
 * @param {number}   bandwidth - Gl√§ttungsparameter
 * @param {number}   points    - Aufl√∂sung der Kurve
 * @returns {{ xs: number[], ys: number[] }}
 */
function kernelDensityEstimator(sample, bandwidth = 0.15, points = 250) {
    const min  = Math.min(...sample);
    const max  = Math.max(...sample);
    const step = (max - min) / points;
    const xs   = [];
    const ys   = [];
    const norm = 1 / (sample.length * bandwidth * Math.sqrt(2 * Math.PI));

    for (let i = 0; i <= points; i++) {
        const x = min + i * step;
        let sum = 0;
        for (let j = 0; j < sample.length; j++) {
            const u = (x - sample[j]) / bandwidth;
            sum    += Math.exp(-0.5 * u * u);
        }
        xs.push(x);
        ys.push(sum * norm);
    }
    return { xs, ys };
}

/**
 * Berechnet den Expected Loss f√ºr jede Variante.
 * Der Expected Loss ist der erwartete entgangene Gewinn,
 * wenn man diese Variante w√§hlt und sie nicht die Beste ist.
 *
 * E[Loss_i] = E[max_k(Œ∏_k) - Œ∏_i]
 *
 * @param {Float32Array[]} posteriors - Posterior-Sample-Arrays
 * @param {number}         n          - Anzahl Samples
 * @returns {number[]} - Expected Loss pro Variante (als Anteil, nicht %)
 */
function calcExpectedLoss(posteriors, n) {
    const losses = new Array(posteriors.length).fill(0);

    for (let j = 0; j < n; j++) {
        // Bestes Sample in diesem Draw
        let bestVal = -Infinity;
        for (let k = 0; k < posteriors.length; k++) {
            if (posteriors[k][j] > bestVal) bestVal = posteriors[k][j];
        }
        // Verlust f√ºr jede Variante = Differenz zum Besten
        for (let i = 0; i < posteriors.length; i++) {
            losses[i] += bestVal - posteriors[i][j];
        }
    }

    return losses.map(l => l / n);
}


// ============================================================
// I. ANALYSE-ORCHESTRIERUNG
// ============================================================

/**
 * Hauptfunktion ‚Äì wird durch "Analyse starten" ausgel√∂st.
 *
 * Ablauf:
 *  1. Alle Analyse-Boxen validieren
 *  2. Spinner anzeigen
 *  3. Pro Box: Sampling via Web Worker + Statistiken berechnen
 *  4. Alle Ergebnisse rendern (Tab pro Box)
 *
 * @returns {Promise<void>}
 */
async function runTest() {
    // 1. Validierung ‚Äì liest alle Boxen
    const { valid, analyses, error } = parseAndValidate();
    showAlert(error || '');
    if (!valid) return;

    // 2. UI-Feedback
    document.getElementById('spinner').classList.add('active');
    document.getElementById('results').innerHTML = '';
    document.getElementById('shareBtn').style.display = 'none';

    const numSamples = Math.min(100000, Math.max(1000,
        parseInt(document.getElementById('numSamples').value, 10) || 10000));
    const threshold  = Math.min(0.9999, Math.max(0.5,
        parseFloat(document.getElementById('threshold').value) / 100));
    const ciLevel    = Math.min(0.9999, Math.max(0.5,
        parseFloat(document.getElementById('ciLevel').value) / 100));

    try {
        // 3. F√ºr jede Analyse-Box: unabh√§ngiges Sampling + Stats
        const boxResults = [];

        for (const analysis of analyses) {
            const posteriors = await samplePosteriorsInWorker(analysis.variants, numSamples);
            const stats      = buildStats(analysis.variants, posteriors, numSamples, ciLevel);

            boxResults.push({
                title:     analysis.title,
                isMain:    analysis.isMain,
                stats,
                posteriors
            });
        }

        // Globaler State speichern (f√ºr CSV-Export und Share-URL)
        lastResults = { boxResults, threshold, ciLevel, numSamples };

        // 4. Ergebnisse rendern
        renderResults(lastResults);

    } catch (err) {
        showAlert('Fehler bei der Berechnung: ' + err.message);
        console.error(err);
    } finally {
        document.getElementById('spinner').classList.remove('active');
    }
}

/**
 * Berechnet alle statistischen Kennzahlen f√ºr eine Analyse-Box.
 * Wiederverwendbar f√ºr beliebige Varianten-Sets.
 *
 * @param {object[]}       variants   - { label, n, c, color, alpha, beta }
 * @param {Float32Array[]} posteriors - Posterior-Sample-Arrays
 * @param {number}         numSamples
 * @param {number}         ciLevel    - z. B. 0.95
 * @returns {object[]}
 */
function buildStats(variants, posteriors, numSamples, ciLevel) {
    // Probability to be Best
    const bestCounts = new Array(variants.length).fill(0);
    for (let j = 0; j < numSamples; j++) {
        let bestIdx = 0, bestVal = posteriors[0][j];
        for (let k = 1; k < posteriors.length; k++) {
            if (posteriors[k][j] > bestVal) { bestVal = posteriors[k][j]; bestIdx = k; }
        }
        bestCounts[bestIdx]++;
    }
    const probBest = bestCounts.map(c => c / numSamples);

    // Probability vs. Control (Index 0)
    const probVsControl = posteriors.map((p, i) => {
        if (i === 0) return null;
        let count = 0;
        for (let j = 0; j < numSamples; j++) {
            if (p[j] > posteriors[0][j]) count++;
        }
        return count / numSamples;
    });

    const losses      = calcExpectedLoss(posteriors, numSamples);
    const controlRate = variants[0].c / variants[0].n;

    return posteriors.map((p, i) => {
        const interval = hdi(p, ciLevel);
        const rate     = variants[i].c / variants[i].n;
        return {
            label:         variants[i].label,
            color:         variants[i].color,
            n:             variants[i].n,
            c:             variants[i].c,
            rate,
            median:        quantile(p, 0.5),
            hdiLower:      interval.lower,
            hdiUpper:      interval.upper,
            probBest:      probBest[i],
            probVsControl: probVsControl[i],
            loss:          losses[i],
            uplift:        i === 0 ? null : (rate - controlRate) / controlRate
        };
    });
}


// ============================================================
// J. RENDER-FUNKTIONEN
// ============================================================

/**
 * Haupt-Render-Funktion.
 *
 * Rendert einen Tab-Container mit einem Tab pro Analyse-Box.
 * Gibt es nur eine Box, wird keine Tab-Leiste gezeigt.
 *
 * @param {object} data - lastResults aus runTest()
 */
function renderResults(data) {
    const { boxResults, threshold, ciLevel } = data;
    const container = document.getElementById('results');
    container.innerHTML = '';

    const hasMultiple = boxResults.length > 1;

    if (hasMultiple) {
        // ‚îÄ‚îÄ Tabs-Wrapper ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        const tabWrapper = document.createElement('div');
        tabWrapper.className = 'glass result-panel';

        // Tab-Leiste
        const tabBar = document.createElement('div');
        tabBar.className = 'tab-bar';
        tabWrapper.appendChild(tabBar);

        boxResults.forEach((box, bi) => {
            // Tab-Button
            const btn = document.createElement('button');
            btn.className   = `tab-btn${bi === 0 ? ' active' : ''}`;
            btn.textContent = box.title;
            btn.onclick     = () => switchTab(bi, tabWrapper);
            tabBar.appendChild(btn);

            // Inhalts-Panel
            const panel = document.createElement('div');
            panel.className = `tab-panel${bi === 0 ? ' active' : ''}`;
            panel.dataset.tabIdx = bi;
            renderAnalysisInto(panel, box.stats, box.posteriors, threshold, ciLevel);
            tabWrapper.appendChild(panel);
        });

        container.appendChild(tabWrapper);

    } else {
        // Nur eine Box ‚Üí kein Tab-UI n√∂tig
        renderAnalysisInto(container, boxResults[0].stats, boxResults[0].posteriors, threshold, ciLevel);
    }

    document.getElementById('shareBtn').style.display = 'inline-flex';
}

/**
 * Schaltet den aktiven Tab im Tab-Wrapper um.
 *
 * @param {number}      idx     - Index des zu aktivierenden Tabs
 * @param {HTMLElement} wrapper - Der Tab-Wrapper-Container
 */
function switchTab(idx, wrapper) {
    wrapper.querySelectorAll('.tab-panel').forEach(p => p.classList.remove('active'));
    wrapper.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));

    const panel = wrapper.querySelector(`[data-tab-idx="${idx}"]`);
    const btns  = wrapper.querySelectorAll('.tab-btn');
    if (panel)     panel.classList.add('active');
    if (btns[idx]) btns[idx].classList.add('active');
}

/**
 * Rendert alle Analyse-Panels in einen Container.
 * Wird f√ºr jeden Tab (bzw. direkt ohne Tabs) aufgerufen.
 */
function renderAnalysisInto(container, stats, posteriors, threshold, ciLevel) {
    renderSummaryMetrics(container, stats);
    renderDensityChart(container, stats, posteriors, ciLevel);
    renderProbabilities(container, stats, threshold);
    renderCredibleIntervals(container, stats, ciLevel);
    renderExpectedLoss(container, stats);
    renderDecision(container, stats, threshold);
}

// ------------------------------------------------------------
// J.1 Zusammenfassende Metriken (Conversion Rates auf einen Blick)
// ------------------------------------------------------------
/**
 * Rendert eine Zeile mit kleinen Metric-Cards,
 * eine pro Variante, mit CR, Besucher, Conversions.
 */
function renderSummaryMetrics(container, stats) {
    const panel = createPanel();

    // √úberschrift mit Tooltip
    panel.innerHTML = `
        <div class="section-title">
            √úbersicht
            <span class="tooltip-wrap">
                <span class="tooltip-icon">i</span>
                <span class="tooltip-box">Rohe Eingabedaten mit beobachteten Conversion Rates. Diese sind punktuelle Sch√§tzungen ohne Unsicherheit.</span>
            </span>
        </div>
        <div class="grid-3" id="metricCards"></div>
    `;

    const grid = panel.querySelector('#metricCards');

    stats.forEach((s, i) => {
        const upliftHtml = s.uplift !== null
            ? `<div class="metric-sub">${formatUplift(s.uplift)} vs. Control</div>`
            : `<div class="metric-sub">Baseline</div>`;

        const card = document.createElement('div');
        card.className = 'metric-card';
        card.innerHTML = `
            <div class="metric-label" style="color:${s.color};">
                ${escapeHTML(s.label)}
            </div>
            <div class="metric-value">${(s.rate * 100).toFixed(2)}%</div>
            <div class="metric-sub">${s.c.toLocaleString()} / ${s.n.toLocaleString()} Conversions</div>
            ${upliftHtml}
        `;
        grid.appendChild(card);
    });

    // CSV-Export-Button
    const exportBtn = document.createElement('button');
    exportBtn.className = 'btn btn-ghost';
    exportBtn.style.cssText = 'margin-top:20px; font-size:13px;';
    exportBtn.textContent = '‚¨á Ergebnisse als CSV';
    exportBtn.onclick     = exportCSV;
    panel.appendChild(exportBtn);

    container.appendChild(panel);
}

// ------------------------------------------------------------
// J.2 Density-Chart (Plotly)
// ------------------------------------------------------------
/**
 * Rendert die Posterior-Dichteverteilungen als gef√ºllte Linienkurven.
 * Zus√§tzlich werden vertikale Linien f√ºr die HDI-Grenzen eingezeichnet.
 *
 * @param {HTMLElement}    container
 * @param {object[]}       stats
 * @param {Float32Array[]} posteriors
 * @param {number}         ciLevel    - z. B. 0.95
 */
function renderDensityChart(container, stats, posteriors, ciLevel) {
    const panel = createPanel();
    panel.innerHTML = `
        <div class="section-title">
            Posterior-Verteilungen
            <span class="tooltip-wrap">
                <span class="tooltip-icon">i</span>
                <span class="tooltip-box">Jede Kurve zeigt die Wahrscheinlichkeitsverteilung der wahren Conversion Rate. Breite Kurven = hohe Unsicherheit (wenig Daten). Die gestrichelten Linien markieren das ${(ciLevel*100).toFixed(0)}%-HDI.</span>
            </span>
        </div>
        <div id="densityPlot" style="width:100%;min-height:340px;"></div>
    `;
    container.appendChild(panel);

    if (typeof Plotly === 'undefined') return;

    const traces = [];

    posteriors.forEach((p, i) => {
        const s            = stats[i];
        const samplePct    = Array.from(p).map(v => v * 100);
        const density      = kernelDensityEstimator(samplePct, 0.15);

        // Haupt-Dichtefl√§che
        traces.push({
            x:    density.xs,
            y:    density.ys,
            mode: 'lines',
            name: s.label,
            line: { color: s.color, width: 2.5 },
            fill: 'tozeroy',
            fillcolor: hexToRgba(s.color, 0.12),
            type: 'scatter'
        });

        // Vertikale Linie f√ºr HDI-Lower
        traces.push({
            x:    [s.hdiLower * 100, s.hdiLower * 100],
            y:    [0, Math.max(...density.ys) * 0.85],
            mode: 'lines',
            line: { color: s.color, width: 1.5, dash: 'dot' },
            showlegend: false,
            hoverinfo: 'none',
            type: 'scatter'
        });

        // Vertikale Linie f√ºr HDI-Upper
        traces.push({
            x:    [s.hdiUpper * 100, s.hdiUpper * 100],
            y:    [0, Math.max(...density.ys) * 0.85],
            mode: 'lines',
            line: { color: s.color, width: 1.5, dash: 'dot' },
            showlegend: false,
            hoverinfo: 'none',
            type: 'scatter'
        });
    });

    const isDark = document.body.classList.contains('dark');

    Plotly.newPlot(panel.querySelector('#densityPlot'), traces, {
        paper_bgcolor: 'rgba(0,0,0,0)',
        plot_bgcolor:  'rgba(0,0,0,0)',
        margin:  { t: 16, r: 20, b: 50, l: 50 },
        legend:  { orientation: 'h', y: -0.18, font: { size: 12 } },
        xaxis: {
            title:      'Conversion Rate (%)',
            gridcolor:  isDark ? 'rgba(255,255,255,0.06)' : 'rgba(0,0,0,0.06)',
            zerolinecolor: isDark ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)',
            tickfont:   { size: 11 },
            color:      isDark ? '#a1a1aa' : '#71717a'
        },
        yaxis: {
            title:      'Dichte',
            gridcolor:  isDark ? 'rgba(255,255,255,0.06)' : 'rgba(0,0,0,0.06)',
            tickfont:   { size: 11 },
            color:      isDark ? '#a1a1aa' : '#71717a'
        },
        font: { family: 'DM Sans' }
    }, { responsive: true, displayModeBar: false });
}

// ------------------------------------------------------------
// J.3 Wahrscheinlichkeiten (Probability to be Best / vs. Baseline)
// ------------------------------------------------------------
/**
 * Rendert zwei nebeneinander liegende Panels:
 *  - Links:  "Probability to be Best" mit Fortschrittsbalken
 *  - Rechts: "Probability to beat Baseline"
 */
function renderProbabilities(container, stats, threshold) {
    const wrapper = document.createElement('div');
    wrapper.className = 'grid-2';

    // --- Links: Probability to be Best ---
    const bestPanel = createPanel('result-panel');
    bestPanel.innerHTML = `
        <div class="section-title">
            Probability to be Best
            <span class="tooltip-wrap">
                <span class="tooltip-icon">i</span>
                <span class="tooltip-box">Wahrscheinlichkeit, dass diese Variante die h√∂chste wahre Conversion Rate unter allen getesteten Varianten hat.</span>
            </span>
        </div>
    `;

    stats.forEach((s) => {
        const pct = (s.probBest * 100).toFixed(1);
        const isAboveThreshold = s.probBest >= threshold;

        const entry = document.createElement('div');
        entry.className = 'ci-entry';
        entry.innerHTML = `
            <div style="width:100%;">
                <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:6px;">
                    <span class="variant-badge" style="background:${hexToRgba(s.color,0.12)};color:${s.color};">
                        ${escapeHTML(s.label)}
                    </span>
                    <span style="font-family:'Fira Code',monospace; font-weight:600; font-size:15px; color:${isAboveThreshold ? 'var(--success)' : 'var(--text-primary)'};">
                        ${pct}%
                        ${isAboveThreshold ? '‚úì' : ''}
                    </span>
                </div>
                <div class="prob-bar-wrap">
                    <div class="prob-bar" style="width:${pct}%; background:${s.color};"></div>
                </div>
            </div>
        `;
        bestPanel.appendChild(entry);
    });

    bestPanel.innerHTML += `<div class="small-text">Entscheidungsgrenze: ${(threshold*100).toFixed(0)}% ‚Äì Varianten, die diese Schwelle √ºberschreiten (‚úì), gelten als statistisch aussagekr√§ftig.</div>`;

    // --- Rechts: Probability to beat Baseline ---
    const basePanel = createPanel('result-panel');
    basePanel.innerHTML = `
        <div class="section-title">
            Prob. to beat Baseline
            <span class="tooltip-wrap">
                <span class="tooltip-icon">i</span>
                <span class="tooltip-box">Wahrscheinlichkeit, dass diese Variante eine h√∂here wahre Conversion Rate als die Control-Gruppe hat. Gilt nur f√ºr Test-Varianten.</span>
            </span>
        </div>
    `;

    stats.forEach((s, i) => {
        if (i === 0) return; // Control √ºberspringen
        const pct     = (s.probVsControl * 100).toFixed(1);
        const isWin   = s.probVsControl >= threshold;

        const entry = document.createElement('div');
        entry.className = 'ci-entry';
        entry.innerHTML = `
            <div style="width:100%;">
                <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:6px;">
                    <span class="variant-badge" style="background:${hexToRgba(s.color,0.12)};color:${s.color};">
                        ${escapeHTML(s.label)}
                    </span>
                    <span style="font-family:'Fira Code',monospace; font-weight:600; font-size:15px; color:${isWin ? 'var(--success)' : 'var(--text-primary)'};">
                        ${pct}% ${isWin ? '‚úì' : ''}
                    </span>
                </div>
                <div class="prob-bar-wrap">
                    <div class="prob-bar" style="width:${pct}%; background:${s.color};"></div>
                </div>
                <div style="margin-top:6px; font-size:12px; color:var(--text-muted);">
                    Uplift: ${formatUplift(s.uplift)}
                </div>
            </div>
        `;
        basePanel.appendChild(entry);
    });

    basePanel.innerHTML += `<div class="small-text">Vergleich jeder Test-Variante direkt mit dem Control. Unabh√§ngig von anderen Varianten.</div>`;

    wrapper.appendChild(bestPanel);
    wrapper.appendChild(basePanel);
    container.appendChild(wrapper);
}

// ------------------------------------------------------------
// J.4 Credible Intervals (HDI-Tabelle)
// ------------------------------------------------------------
/**
 * Rendert eine Tabelle mit dem Highest Density Interval (HDI)
 * und dem Posterior-Median f√ºr jede Variante.
 */
function renderCredibleIntervals(container, stats, ciLevel) {
    const panel = createPanel('result-panel');
    panel.innerHTML = `
        <div class="section-title">
            ${(ciLevel * 100).toFixed(0)}% Credible Intervals (HDI)
            <span class="tooltip-wrap">
                <span class="tooltip-icon">i</span>
                <span class="tooltip-box">Das Highest Density Interval (HDI) ist das schmalste Intervall, das ${(ciLevel*100).toFixed(0)}% der Posterior-Wahrscheinlichkeit enth√§lt. Anders als ein frequentistisches KI kann man sagen: "Mit ${(ciLevel*100).toFixed(0)}% Wahrscheinlichkeit liegt die wahre CR in diesem Bereich."</span>
            </span>
        </div>
    `;

    stats.forEach((s) => {
        const entry = document.createElement('div');
        entry.className = 'ci-entry';
        entry.innerHTML = `
            <div class="ci-left">
                <span class="variant-badge" style="background:${hexToRgba(s.color,0.12)};color:${s.color};">
                    ${escapeHTML(s.label)}
                </span>
            </div>
            <div class="ci-values">
                <div class="ci-stat">
                    <div class="ci-stat-label">Untergrenze</div>
                    <div class="ci-stat-value">${(s.hdiLower * 100).toFixed(2)}%</div>
                </div>
                <div class="ci-stat">
                    <div class="ci-stat-label">Median</div>
                    <div class="ci-stat-value">${(s.median * 100).toFixed(2)}%</div>
                </div>
                <div class="ci-stat">
                    <div class="ci-stat-label">Obergrenze</div>
                    <div class="ci-stat-value">${(s.hdiUpper * 100).toFixed(2)}%</div>
                </div>
                <div class="ci-stat">
                    <div class="ci-stat-label">Breite</div>
                    <div class="ci-stat-value">${((s.hdiUpper - s.hdiLower) * 100).toFixed(2)}pp</div>
                </div>
            </div>
        `;
        panel.appendChild(entry);
    });

    panel.innerHTML += `
        <div class="small-text">
            <b>Breite des HDI:</b> Ein schmales Intervall (wenige Prozentpunkte) bedeutet hohe Sicherheit √ºber die wahre CR.
            Ein breites Intervall signalisiert, dass mehr Daten ben√∂tigt werden.
        </div>
    `;
    container.appendChild(panel);
}

// ------------------------------------------------------------
// J.5 Expected Loss
// ------------------------------------------------------------
/**
 * Rendert den Expected Loss pro Variante.
 * Niedrige Werte = sicherere Entscheidung.
 */
function renderExpectedLoss(container, stats) {
    const panel = createPanel('result-panel');
    panel.innerHTML = `
        <div class="section-title">
            Expected Loss
            <span class="tooltip-wrap">
                <span class="tooltip-icon">i</span>
                <span class="tooltip-box">Durchschnittlicher entgangener Gewinn (in Prozentpunkten CR), wenn wir uns f√ºr diese Variante entscheiden, aber eine andere besser gewesen w√§re. Kombiniert Fehlerwahrscheinlichkeit und Fehlergr√∂√üe. Niedriger ist besser.</span>
            </span>
        </div>
    `;

    // Besten (niedrigsten) Loss identifizieren
    const minLoss = Math.min(...stats.map(s => s.loss));

    stats.forEach((s) => {
        const lossPct = (s.loss * 100).toFixed(3);
        const isBest  = s.loss === minLoss;
        const bg      = isBest
            ? 'background:var(--success-soft); border-color:rgba(34,197,94,0.2);'
            : '';

        const entry = document.createElement('div');
        entry.className = 'ci-entry';
        entry.style.cssText = bg;
        entry.innerHTML = `
            <div class="ci-left">
                <span class="variant-badge" style="background:${hexToRgba(s.color,0.12)};color:${s.color};">
                    ${escapeHTML(s.label)}
                </span>
                ${isBest ? '<span style="font-size:12px;color:var(--success);font-weight:600;">Niedrigster Loss ‚úì</span>' : ''}
            </div>
            <div style="font-family:\'Fira Code\',monospace; font-weight:600; font-size:16px;">
                ${lossPct}%
            </div>
        `;
        panel.appendChild(entry);
    });

    panel.innerHTML += `
        <div class="small-text">
            <b>Expected Loss</b> ber√ºcksichtigt sowohl die Wahrscheinlichkeit einer Fehlentscheidung als auch deren Ausma√ü.
            Er ist damit robuster als reine Gewinnwahrscheinlichkeiten.
            Ein Wert nahe 0% bedeutet, dass selbst im Fehlerfall kaum Performance verloren geht.
        </div>
    `;
    container.appendChild(panel);
}

// ------------------------------------------------------------
// J.6 Entscheidungsempfehlung
// ------------------------------------------------------------
/**
 * Rendert die finale Empfehlungsbox in Gr√ºn / Gelb / Rot,
 * abh√§ngig von Gewinnwahrscheinlichkeit und Expected Loss.
 */
function renderDecision(container, stats, threshold) {
    const maxProbBest   = Math.max(...stats.map(s => s.probBest));
    const winnerIdx     = stats.findIndex(s => s.probBest === maxProbBest);
    const winner        = stats[winnerIdx];
    const minLoss       = Math.min(...stats.map(s => s.loss));

    // Entscheidungslogik ‚Äì drei Stufen
    let type, icon, title, body;
    // winner.label aus Nutzereingabe ‚Üí wird in innerHTML injiziert ‚Üí escapen
    const safeLabel = escapeHTML(winner.label);

    if (maxProbBest >= threshold && minLoss < 0.0001) {
        type  = 'success';
        icon  = '‚úÖ';
        title = `Empfehlung: ${safeLabel} einf√ºhren`;
        body  = `
            <b>${safeLabel}</b> hat eine Gewinnwahrscheinlichkeit von
            <b>${(maxProbBest * 100).toFixed(1)}%</b> ‚Äì √ºber der gesetzten Entscheidungsgrenze von
            ${(threshold * 100).toFixed(0)}%.<br><br>
            Der Expected Loss betr√§gt <b>${(minLoss * 100).toFixed(3)}%</b> ‚Äì selbst im unwahrscheinlichen
            Fehlerfall w√§re der Performance-Verlust vernachl√§ssigbar.<br><br>
            Relativer Uplift vs. Control:
            <b>${winner.uplift !== null ? formatUplift(winner.uplift) : 'Control'}</b>
        `;
    } else if (maxProbBest >= 0.75) {
        type  = 'warning';
        icon  = '‚è≥';
        title = `Tendenz: ${safeLabel} f√ºhrt ‚Äì Test fortsetzen`;
        body  = `
            <b>${safeLabel}</b> liegt vorne mit ${(maxProbBest * 100).toFixed(1)}% Gewinnwahrscheinlichkeit,
            hat aber die Entscheidungsgrenze von ${(threshold * 100).toFixed(0)}% noch nicht erreicht.<br><br>
            Expected Loss: <b>${(minLoss * 100).toFixed(3)}%</b> ‚Äì noch nicht gering genug
            f√ºr eine sichere Entscheidung.<br><br>
            Empfehlung: Weitere Daten sammeln, um die Unsicherheit zu reduzieren.
        `;
    } else {
        type  = 'danger';
        icon  = 'üîç';
        title = 'Keine klare Entscheidung m√∂glich';
        body  = `
            Keine Variante √ºberschreitet die Entscheidungsgrenze von ${(threshold * 100).toFixed(0)}%.
            Der geringste Expected Loss liegt bei <b>${(minLoss * 100).toFixed(3)}%</b>,
            was noch erhebliche Unsicherheit anzeigt.<br><br>
            Empfehlung: Mehr Daten sammeln oder den Test neu aufsetzen.
        `;
    }

    const box = document.createElement('div');
    box.className = `decision-box ${type} result-panel`;
    box.innerHTML = `
        <div class="decision-title">${icon} ${title}</div>
        <div style="color:var(--text-secondary); line-height:1.7;">${body}</div>
    `;
    container.appendChild(box);
}


// ============================================================
// K. CSV-EXPORT
// ============================================================

/**
 * Exportiert alle Analyse-Boxen als CSV.
 * Jede Box wird als separater Block mit dem Box-Titel als "Segment"-Spalte exportiert.
 */
function exportCSV() {
    if (!lastResults) return;

    const { boxResults, ciLevel } = lastResults;
    const ci = (ciLevel * 100).toFixed(0);

    const headers = [
        'Analyse', 'Variante', 'Besucher', 'Conversions', 'Conversion Rate (%)',
        'Relativer Uplift (%)', 'Prob. to be Best (%)', 'Prob. vs. Control (%)',
        `HDI Lower ${ci}% (%)`, 'Median (%)', `HDI Upper ${ci}% (%)`,
        'Expected Loss (%)'
    ];

    const allRows = boxResults.flatMap(box =>
        box.stats.map(s => [
            box.title,
            s.label,
            s.n,
            s.c,
            (s.rate * 100).toFixed(3),
            s.uplift !== null ? (s.uplift * 100).toFixed(2) : 'Baseline',
            (s.probBest * 100).toFixed(2),
            s.probVsControl !== null ? (s.probVsControl * 100).toFixed(2) : 'Baseline',
            (s.hdiLower * 100).toFixed(3),
            (s.median * 100).toFixed(3),
            (s.hdiUpper * 100).toFixed(3),
            (s.loss * 100).toFixed(4)
        ])
    );

    const csv  = [headers, ...allRows].map(r => r.join(',')).join('\n');
    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
    const url  = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href     = url;
    link.download = `ab_test_${new Date().toISOString().slice(0, 10)}.csv`;
    link.click();
    URL.revokeObjectURL(url);
}


// ============================================================
// HILFSFUNKTIONEN
// ============================================================

/**
 * Escapet einen String f√ºr sicheres Einf√ºgen in innerHTML.
 *
 * Warum n√∂tig: Varianten-Namen und Box-Titel werden vom Nutzer
 * frei eingegeben und anschlie√üend via Template-Literal in
 * innerHTML geschrieben. Ohne Escaping k√∂nnte ein Name wie
 *   <img src=x onerror=alert(1)>
 * als HTML interpretiert werden (Stored-XSS innerhalb der Seite).
 *
 * Diese Funktion ersetzt die f√ºnf HTML-Sonderzeichen durch ihre
 * Entit√§ten, bevor der String in den DOM gelangt.
 *
 * @param {string} str - Beliebiger Nutzer-String
 * @returns {string}   - HTML-sicherer String
 */
function escapeHTML(str) {
    return String(str)
        .replace(/&/g,  '&amp;')
        .replace(/</g,  '&lt;')
        .replace(/>/g,  '&gt;')
        .replace(/"/g,  '&quot;')
        .replace(/'/g,  '&#039;');
}

/**
 * @param {string} extraClass - Optional weitere CSS-Klasse
 * @returns {HTMLElement}
 */
function createPanel(extraClass = '') {
    const el = document.createElement('div');
    el.className = `glass result-panel ${extraClass}`.trim();
    return el;
}

/**
 * Wandelt einen Hex-Farbcode in rgba() um.
 *
 * @param {string} hex   - z. B. '#5b6cf9'
 * @param {number} alpha - Transparenz [0,1]
 * @returns {string}     - z. B. 'rgba(91,108,249,0.12)'
 */
function hexToRgba(hex, alpha) {
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);
    return `rgba(${r},${g},${b},${alpha})`;
}

/**
 * Formatiert einen relativen Uplift-Wert als farbigen Chip-String.
 *
 * @param {number|null} uplift - Dezimalzahl, z. B. 0.12 f√ºr +12%
 * @returns {string} HTML-String
 */
function formatUplift(uplift) {
    if (uplift === null) return '‚Äì';
    const pct = (uplift * 100).toFixed(1);
    const cls = uplift > 0 ? 'uplift-pos' : uplift < 0 ? 'uplift-neg' : 'uplift-neu';
    const sign = uplift > 0 ? '+' : '';
    return `<span class="uplift-chip ${cls}">${sign}${pct}%</span>`;
}

</script>
</body>
</html>