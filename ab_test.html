<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<!--
    Content Security Policy:
    - script-src: nur das Plotly-CDN + inline-Skripte (n√∂tig f√ºr den Blob-Worker)
    - style-src:  nur Google Fonts + eigene Inline-Styles
    - font-src:   nur Google Fonts
    - connect-src / img-src / object-src: keine externen Verbindungen erlaubt
    Sch√ºtzt gegen XSS-Angriffe, die externe Ressourcen nachladen w√ºrden.
-->
<meta http-equiv="Content-Security-Policy"
      content="default-src 'none';
               script-src 'self' 'unsafe-inline' https://cdn.plot.ly;
               style-src  'self' 'unsafe-inline' https://fonts.googleapis.com;
               font-src   https://fonts.gstatic.com;
               worker-src blob:;
               img-src    data: blob:;">
<title>Bayesian A/B Testing Dashboard</title>
<script defer src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
<!--
    Inter:     Hauptschrift ‚Äì klar, breit, ausgezeichnete Lesbarkeit.
    Fira Code: Zahlen & Monospace-Werte ‚Äì humanistischere Ziffernform,
               klare 0/O-Unterscheidung, angenehm bei Dezimalzahlen.
-->
<!-- IBM Plex Mono: exzellente Tabular-Figures, klar lesbare Ziffern, kein Styling-Noise -->
<link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500&family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">

<!-- ============================================================
     STYLESHEET
     Aufgeteilt in:
       1. CSS Custom Properties (Design Tokens)
       2. Base & Reset
       3. Layout-Komponenten (.glass, .grid-2, etc.)
       4. Formular-Elemente (Input, Button, Tooltip)
       5. Ergebnis-Komponenten (KPI, CI-Entry, Badge)
       6. Dark Mode Overrides
       7. Animationen
     ============================================================ -->
<style>

/* ----------------------------------------------------------
   1. CSS Custom Properties ‚Äì alle Farben, Abst√§nde, Radii
      an einem zentralen Ort definiert.
      Dark-Mode-Overrides werden im body.dark-Block gesetzt.
   ---------------------------------------------------------- */
:root {
    /* Hintergrund ‚Äì neutrales Warmgrau statt Blau-Lila */
    --bg:              #f5f5f4;
    --bg-gradient:     linear-gradient(160deg, #f5f5f4 0%, #f0f0ef 100%);

    /* Glassmorphism-Karten */
    --glass-bg:        rgba(255, 255, 255, 0.78);
    --glass-border:    rgba(0, 0, 0, 0.07);
    --glass-shadow:    0 2px 16px rgba(0, 0, 0, 0.07);

    /* Typografie */
    --text-primary:    #1c1917;
    --text-secondary:  #57534e;
    --text-muted:      #a8a29e;

    /* Akzent ‚Äì ged√§mpftes Schieferblau statt Indigo */
    --accent:          #3b5bdb;
    --accent-soft:     rgba(59, 91, 219, 0.10);
    --accent-hover:    #2f4bbf;

    /* Semantische Farben ‚Äì ges√§ttigter, aber nicht grell */
    --success:         #2d8a4e;
    --success-soft:    rgba(45, 138, 78, 0.10);
    --warning:         #b45309;
    --warning-soft:    rgba(180, 83, 9, 0.10);
    --danger:          #c0392b;
    --danger-soft:     rgba(192, 57, 43, 0.10);

    /* Varianten-Farben ‚Äì ged√§mpft, harmonisch */
    --c0: #3b5bdb;   /* Control  ‚Äì Schieferblau  */
    --c1: #c2440e;   /* Var 1    ‚Äì Terrakotta    */
    --c2: #2d8a4e;   /* Var 2    ‚Äì Tannengr√ºn    */
    --c3: #7c3d8f;   /* Var 3    ‚Äì Pflaume       */
    --c4: #0e7490;   /* Var 4    ‚Äì Petrol        */

    /* Abst√§nde & Radii */
    --radius-sm:   8px;
    --radius-md:   14px;
    --radius-lg:   20px;
    --gap:         24px;
    --pad:         28px;

    /* √úberg√§nge */
    --transition:  all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
}

/* ----------------------------------------------------------
   2. Base & Reset
   ---------------------------------------------------------- */
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

body {
    /*
     * Inter statt DM Sans:
     *  ‚Äì gr√∂√üere x-H√∂he ‚Üí Buchstaben wirken gr√∂√üer bei gleicher Schriftgr√∂√üe
     *  ‚Äì optimiert f√ºr Bildschirme, hervorragendes Hinting
     *  ‚Äì weite Abst√§nde zwischen Zeichen (letter-spacing leicht reduziert)
     */
    font-family: 'Inter', sans-serif;
    font-size: 15.5px;          /* leicht erh√∂ht f√ºr angenehmeres Lesen */
    line-height: 1.65;          /* mehr Zeilenabstand = ruhigeres Schriftbild */
    letter-spacing: -0.01em;    /* Inter wirkt sonst etwas zu weit */
    color: var(--text-primary);
    background: var(--bg-gradient);
    min-height: 100vh;
    padding: 56px 64px 80px;
    transition: var(--transition);
}

/* ----------------------------------------------------------
   3. Layout-Komponenten
   ---------------------------------------------------------- */

/* Seiten-Header */
.page-header {
    display: flex;
    align-items: flex-start;
    justify-content: space-between;
    margin-bottom: 48px;
}

.page-title {
    font-size: 28px;
    font-weight: 600;
    letter-spacing: -0.5px;
    color: var(--text-primary);
}

.page-subtitle {
    font-size: 14px;
    color: var(--text-muted);
    margin-top: 4px;
    font-family: 'IBM Plex Mono', monospace;
}

/* Glassmorphism-Karte ‚Äì Basis-Baustein f√ºr alle Panels */
.glass {
    background: var(--glass-bg);
    backdrop-filter: blur(28px);
    -webkit-backdrop-filter: blur(28px);
    border: 1.5px solid var(--glass-border);
    border-radius: var(--radius-lg);
    padding: var(--pad);
    margin-bottom: var(--gap);
    box-shadow: var(--glass-shadow);
    transition: var(--transition);
}

/* Zweispalten-Grid ‚Äì wird f√ºr KPI-Row und CI-Tabelle genutzt */
.grid-2 {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: var(--gap);
}

/* Dreispalten-Grid f√ºr Metriken-√úbersicht */
.grid-3 {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 16px;
    margin-bottom: var(--gap);
}

/* Abschnitt-√úberschrift mit optionaler Beschreibung */
.section-title {
    font-size: 16px;
    font-weight: 600;
    color: var(--text-primary);
    margin-bottom: 20px;
    display: flex;
    align-items: center;
    gap: 8px;
}

/* ----------------------------------------------------------
   4. Formular-Elemente ‚Äì Tabellen-Layout f√ºr Varianten
   ---------------------------------------------------------- */

/* Spaltenk√∂pfe √ºber der ersten Varianten-Zeile */
.variant-col-header {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 0 4px 6px 4px;
    border-bottom: 1px solid rgba(0,0,0,0.07);
    margin-bottom: 6px;
}

.col-spacer      { width: 10px; flex-shrink: 0; }        /* Farbpunkt */
.col-spacer-cr   { font-size: 11px; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.4px; font-weight: 500; min-width: 115px; padding-left: 4px; }
.col-spacer-name { width: 130px; flex-shrink: 0; }       /* Name-Input */
.btn-remove-placeholder { width: 26px; flex-shrink: 0; }

/* Editierbare Spaltenbezeichnung */
.col-label-input {
    font-size: 11px;
    color: var(--text-secondary);
    text-transform: uppercase;
    letter-spacing: 0.5px;
    font-weight: 600;
    background: transparent;
    border: 1.5px solid transparent;
    border-radius: 5px;
    padding: 2px 6px;
    width: 105px;
    outline: none;
    font-family: 'Inter', sans-serif;
    transition: var(--transition);
    cursor: pointer;
}
.col-label-input:hover { border-color: rgba(0,0,0,0.10); background: rgba(0,0,0,0.03); }
.col-label-input:focus { border-color: var(--accent); background: white; color: var(--text-primary); cursor: text; }
body.dark .col-label-input:hover { border-color: rgba(255,255,255,0.12); background: rgba(255,255,255,0.04); }
body.dark .col-label-input:focus { background: rgba(255,255,255,0.08); }

/* Einzelne Varianten-Zeile */
.variant-row {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 7px 4px;
    border-radius: var(--radius-sm);
    margin-bottom: 3px;
    border: 1.5px solid transparent;
    transition: background 0.15s;
}
.variant-row:hover { background: rgba(0,0,0,0.025); }

/* Farbiger Punkt */
.variant-dot {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    flex-shrink: 0;
}

/* Varianten-Name */
.inp-name {
    width: 130px;
    flex-shrink: 0;
    padding: 6px 10px;
    border-radius: var(--radius-sm);
    border: 1.5px solid transparent;
    background: transparent;
    color: var(--text-primary);
    font-family: 'Inter', sans-serif;
    font-size: 14px;
    font-weight: 500;
    outline: none;
    transition: var(--transition);
}
.inp-name:hover { border-color: rgba(0,0,0,0.10); background: rgba(255,255,255,0.6); }
.inp-name:focus { border-color: var(--accent); background: white; box-shadow: 0 0 0 2px var(--accent-soft); }
body.dark .inp-name:hover { background: rgba(255,255,255,0.05); border-color: rgba(255,255,255,0.12); }
body.dark .inp-name:focus { background: rgba(255,255,255,0.08); }

/* Zahl-Eingabefelder */
input[type="number"],
.inp-visitors,
.inp-conversions {
    padding: 6px 10px;
    border-radius: var(--radius-sm);
    border: 1.5px solid rgba(0,0,0,0.09);
    background: white;
    color: var(--text-primary);
    font-family: 'IBM Plex Mono', monospace;
    font-size: 14px;
    width: 105px;
    outline: none;
    transition: var(--transition);
}

input[type="number"]:focus,
.inp-visitors:focus,
.inp-conversions:focus {
    border-color: var(--accent);
    box-shadow: 0 0 0 2px var(--accent-soft);
}

/* CR + Uplift nebeneinander */
.variant-cr-cell {
    display: flex;
    align-items: center;
    gap: 6px;
    min-width: 115px;
}

/* Conversion Rate ‚Äì live angezeigt */
.variant-rate {
    font-family: 'IBM Plex Mono', monospace;
    font-size: 13px;
    color: var(--text-secondary);
    font-weight: 500;
    min-width: 54px;
}

/* Inlinebeschriftung f√ºr Inputs (Legacy-Kompatibilit√§t) */
.input-group {
    display: flex;
    flex-direction: column;
    gap: 2px;
}

.input-group label {
    font-size: 11px;
    color: var(--text-muted);
    text-transform: uppercase;
    letter-spacing: 0.5px;
    font-weight: 500;
}

/* Validierungsfehler ‚Äì wird per JS gesetzt */
input.invalid {
    border-color: var(--danger);
    background: rgba(239, 68, 68, 0.05);
}

/* Fehlermeldung unter einem Input */
.input-error {
    font-size: 12px;
    color: var(--danger);
    margin-top: 2px;
    display: none;
}

.input-error.visible {
    display: block;
}

/* Prim√§r-Button */
.btn {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    background: var(--accent);
    border: none;
    color: white;
    padding: 11px 22px;
    border-radius: var(--radius-sm);
    cursor: pointer;
    font-family: 'Inter', sans-serif;
    font-size: 14px;
    font-weight: 500;
    transition: var(--transition);
}

.btn:hover {
    background: var(--accent-hover);
    transform: translateY(-1px);
    box-shadow: 0 6px 20px rgba(91, 108, 249, 0.30);
}

.btn:active { transform: translateY(0); }

/* Sekund√§rer (geisterartiger) Button */
.btn-ghost {
    background: transparent;
    border: 1.5px solid rgba(0,0,0,0.12);
    color: var(--text-secondary);
}

.btn-ghost:hover {
    background: rgba(0,0,0,0.04);
    box-shadow: none;
    transform: none;
}

/* Kleiner Entfernen-Button in der Varianten-Zeile */
.btn-remove {
    background: transparent;
    border: none;
    color: var(--text-muted);
    cursor: pointer;
    padding: 4px 8px;
    border-radius: 8px;
    font-size: 16px;
    line-height: 1;
    margin-left: auto;
    transition: var(--transition);
}

.btn-remove:hover { color: var(--danger); background: var(--danger-soft); }

/* Dark-Mode Toggle oben rechts */
.toggle-btn {
    background: rgba(255,255,255,0.6);
    border: 1.5px solid var(--glass-border);
    color: var(--text-primary);
    padding: 9px 18px;
    border-radius: var(--radius-sm);
    cursor: pointer;
    font-size: 13px;
    font-family: 'Inter', sans-serif;
    font-weight: 500;
    transition: var(--transition);
    backdrop-filter: blur(10px);
}

.toggle-btn:hover { background: rgba(255,255,255,0.85); }

/* ----------------------------------------------------------
   Tooltip-System
   Nutzung: <span class="tooltip-wrap">Wort<span class="tooltip-box">Erkl√§rung</span></span>
   ---------------------------------------------------------- */
.tooltip-wrap {
    position: relative;
    display: inline-flex;
    align-items: center;
    gap: 4px;
    cursor: help;
}

/* Das ‚ìò-Icon */
.tooltip-icon {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 16px;
    height: 16px;
    border-radius: 50%;
    background: var(--accent-soft);
    color: var(--accent);
    font-size: 10px;
    font-style: normal;
    font-weight: 600;
    flex-shrink: 0;
}

/* Das Tooltip-Popup */
.tooltip-box {
    position: absolute;
    bottom: calc(100% + 8px);
    left: 50%;
    transform: translateX(-50%);
    background: #18181b;
    color: #f4f4f5;
    font-size: 12px;
    font-weight: 400;
    line-height: 1.5;
    padding: 10px 14px;
    border-radius: 10px;
    width: 240px;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.2s ease;
    z-index: 100;
    white-space: normal;
    font-family: 'Inter', sans-serif;
    box-shadow: 0 8px 24px rgba(0,0,0,0.25);
}

.tooltip-wrap:hover .tooltip-box { opacity: 1; }

/* ----------------------------------------------------------
   5. Ergebnis-Komponenten
   ---------------------------------------------------------- */

/* Kleine Metrik-Kachel (Conversion Rate, Besucher etc.) */
.metric-card {
    background: rgba(255,255,255,0.5);
    border-radius: var(--radius-md);
    padding: 18px 20px;
    border: 1.5px solid rgba(255,255,255,0.9);
}

.metric-label {
    font-size: 11px;
    text-transform: uppercase;
    letter-spacing: 0.6px;
    color: var(--text-muted);
    font-weight: 500;
    margin-bottom: 6px;
}

.metric-value {
    font-size: 24px;       /* von 22px: mehr Pr√§senz bei den Haupt-KPIs */
    font-weight: 600;
    font-family: 'IBM Plex Mono', monospace;
    color: var(--text-primary);
}

.metric-sub {
    font-size: 13px;       /* von 12px: Sub-Zeile besser lesbar */
    color: var(--text-muted);
    margin-top: 3px;
}

/* Varianten-Badge ‚Äì farbiger Chip mit Label */
.variant-badge {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    padding: 3px 10px;
    border-radius: 20px;
    font-size: 13px;       /* von 12px */
    font-weight: 600;
    font-family: 'IBM Plex Mono', monospace;
}

/* Einzel-Zeile in den Ergebnis-Boxen */
.ci-entry {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 14px 18px;
    border-radius: var(--radius-md);
    margin-bottom: 10px;
    background: rgba(255,255,255,0.45);
    border: 1.5px solid rgba(255,255,255,0.7);
    gap: 12px;
    flex-wrap: wrap;
}

.ci-entry:last-of-type { margin-bottom: 0; }

.ci-left {
    display: flex;
    align-items: center;
    gap: 10px;
}

.ci-values {
    display: flex;
    gap: 20px;
    align-items: center;
}

/* Einzelne Kennzahl innerhalb einer ci-values-Gruppe */
.ci-stat {
    text-align: right;
}

.ci-stat-label {
    font-size: 11px;       /* von 10px: Labels besser lesbar */
    text-transform: uppercase;
    letter-spacing: 0.5px;
    color: var(--text-muted);
    font-weight: 500;
}

.ci-stat-value {
    font-family: 'IBM Plex Mono', monospace;
    font-size: 16px;       /* von 15px: Hauptkennzahlen in den Tabellen */
    font-weight: 500;
    color: var(--text-primary);
}

/* Uplift-Chip: gr√ºn bei positivem, rot bei negativem Uplift */
.uplift-chip {
    font-family: 'IBM Plex Mono', monospace;
    font-size: 13px;       /* von 12px */
    font-weight: 600;
    padding: 3px 9px;
    border-radius: 20px;
}

.uplift-pos { background: var(--success-soft); color: var(--success); }
.uplift-neg { background: var(--danger-soft);  color: var(--danger);  }
.uplift-neu { background: rgba(0,0,0,0.06);    color: var(--text-muted); }

/* Fortschrittsbalken f√ºr Wahrscheinlichkeiten */
.prob-bar-wrap {
    width: 100%;
    height: 6px;
    background: rgba(0,0,0,0.07);
    border-radius: 10px;
    margin-top: 6px;
    overflow: hidden;
}

.prob-bar {
    height: 100%;
    border-radius: 10px;
    transition: width 0.6s cubic-bezier(0.4, 0, 0.2, 1);
}

/* Ergebnis-Entscheidungsbox */
.decision-box {
    border-radius: var(--radius-lg);
    padding: var(--pad);
    margin-bottom: var(--gap);
    font-size: 15px;
    line-height: 1.7;
    border: 2px solid transparent;
}

.decision-box.success {
    background: var(--success-soft);
    border-color: rgba(34, 197, 94, 0.25);
}

.decision-box.warning {
    background: var(--warning-soft);
    border-color: rgba(245, 158, 11, 0.25);
}

.decision-box.danger {
    background: var(--danger-soft);
    border-color: rgba(239, 68, 68, 0.2);
}

.decision-title {
    font-size: 17px;
    font-weight: 600;
    margin-bottom: 12px;
    display: flex;
    align-items: center;
    gap: 8px;
}

/* Spinner w√§hrend der Berechnung (via Web Worker) */
.spinner-overlay {
    display: none;
    align-items: center;
    justify-content: center;
    gap: 12px;
    padding: 16px 0;
    color: var(--text-secondary);
    font-size: 14px;
}

.spinner-overlay.active { display: flex; }

.spinner {
    width: 20px;
    height: 20px;
    border: 2px solid var(--accent-soft);
    border-top-color: var(--accent);
    border-radius: 50%;
    animation: spin 0.8s linear infinite;
}

/* Trennlinie mit Text */
.divider {
    display: flex;
    align-items: center;
    gap: 12px;
    color: var(--text-muted);
    font-size: 12px;
    margin: 8px 0 20px;
}

.divider::before, .divider::after {
    content: '';
    flex: 1;
    height: 1px;
    background: rgba(0,0,0,0.08);
}

/* Meldung f√ºr Validierungsfehler (globale Box) */
.alert {
    padding: 14px 18px;
    border-radius: var(--radius-md);
    font-size: 14px;
    margin-bottom: 16px;
    display: none;
}

.alert.visible { display: block; }
.alert.error   { background: var(--danger-soft); color: var(--danger); }

/* Erkl√§rungstext unter Ergebnis-Panels */
.small-text {
    font-size: 13px;
    color: var(--text-muted);
    margin-top: 18px;
    line-height: 1.6;
    padding-top: 16px;
    border-top: 1px solid rgba(0,0,0,0.06);
}

/* ----------------------------------------------------------
   6. Dark Mode Overrides
   ---------------------------------------------------------- */
body.dark {
    --bg-gradient:   linear-gradient(160deg, #141414 0%, #1a1a1a 100%);
    --glass-bg:      rgba(30, 30, 30, 0.90);
    --glass-border:  rgba(255, 255, 255, 0.08);
    --glass-shadow:  0 2px 16px rgba(0, 0, 0, 0.50);
    --text-primary:  #f5f5f4;
    --text-secondary:#a8a29e;
    --text-muted:    #78716c;
    --accent-soft:   rgba(59, 91, 219, 0.20);
}

body.dark input[type="number"],
body.dark .inp-visitors,
body.dark .inp-conversions {
    background: rgba(255,255,255,0.06);
    border-color: rgba(255,255,255,0.10);
    color: var(--text-primary);
}

body.dark .variant-row     { background: rgba(255,255,255,0.04); }
body.dark .metric-card     { background: rgba(255,255,255,0.04); border-color: rgba(255,255,255,0.06); }
body.dark .ci-entry        { background: rgba(255,255,255,0.04); border-color: rgba(255,255,255,0.07); }
body.dark .toggle-btn      { background: rgba(255,255,255,0.08); border-color: rgba(255,255,255,0.12); color: var(--text-primary); }
body.dark .btn-ghost       { border-color: rgba(255,255,255,0.15); color: var(--text-secondary); }
body.dark .btn-ghost:hover { background: rgba(255,255,255,0.06); }
body.dark .divider::before,
body.dark .divider::after  { background: rgba(255,255,255,0.08); }
body.dark .small-text      { border-color: rgba(255,255,255,0.08); }
body.dark #settingsModal   { background: rgba(20,20,35,0.97); border-color: rgba(255,255,255,0.10); }

/* ----------------------------------------------------------
   ANALYSE-BOXEN-SYSTEM
   Jede Analyse-Box ist ein eigenst√§ndiger .glass-Container
   mit einem editierbaren Titel und derselben Varianten-Struktur
   wie die Haupt-Box. Die erste Box ("Gesamt") ist nicht l√∂schbar.
   ---------------------------------------------------------- */

/* Wrapper um alle Analyse-Boxen */
#analysis-boxes {
    display: flex;
    flex-direction: column;
    gap: var(--gap);
}

/* Jede Analyse-Box */
.analysis-box {
    background: var(--glass-bg);
    backdrop-filter: blur(28px);
    -webkit-backdrop-filter: blur(28px);
    border: 1.5px solid var(--glass-border);
    border-radius: var(--radius-lg);
    padding: var(--pad);
    box-shadow: var(--glass-shadow);
    transition: var(--transition);
}

/* Header-Zeile der Box: Titel links, Entfernen-Button rechts */
.analysis-box-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 20px;
    gap: 12px;
}

/* Editierbarer Box-Titel (z. B. "Gesamt", "Elektronik") */
.inp-box-title {
    font-size: 17px;
    font-weight: 600;
    font-family: 'Inter', sans-serif;
    color: var(--text-primary);
    background: transparent;
    border: 1.5px solid transparent;
    border-radius: 8px;
    padding: 4px 10px;
    outline: none;
    transition: var(--transition);
    min-width: 160px;
    flex: 1;
    max-width: 400px;
}

.inp-box-title:hover:not(:focus) {
    border-color: rgba(0,0,0,0.12);
    background: rgba(255,255,255,0.5);
}

.inp-box-title:focus {
    border-color: var(--accent);
    background: rgba(255,255,255,0.85);
    box-shadow: 0 0 0 3px var(--accent-soft);
}

body.dark .inp-box-title:hover:not(:focus) {
    border-color: rgba(255,255,255,0.15);
    background: rgba(255,255,255,0.05);
}
body.dark .inp-box-title:focus {
    background: rgba(255,255,255,0.08);
}

/* Kleines Label "Segment" oder "Gesamt" neben dem Titel */
.box-type-badge {
    font-size: 11px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.6px;
    padding: 3px 9px;
    border-radius: 20px;
    flex-shrink: 0;
}

.box-type-badge.main    { background: var(--accent-soft); color: var(--accent); }
.box-type-badge.segment { background: rgba(245,158,11,0.12); color: var(--warning); }

/* Entfernen-Button f√ºr Analyse-Boxen */
.btn-remove-box {
    background: transparent;
    border: 1.5px solid rgba(0,0,0,0.10);
    color: var(--text-muted);
    cursor: pointer;
    padding: 6px 12px;
    border-radius: 10px;
    font-size: 13px;
    font-family: 'Inter', sans-serif;
    font-weight: 500;
    transition: var(--transition);
    flex-shrink: 0;
}

.btn-remove-box:hover {
    border-color: var(--danger);
    color: var(--danger);
    background: var(--danger-soft);
}

body.dark .btn-remove-box { border-color: rgba(255,255,255,0.12); }

/* ----------------------------------------------------------
   VARIANTEN-NAME ‚Äì Inline-Textfeld
   Das Label ist kein statischer <span> mehr, sondern ein
   editierbares Input-Feld. Es sieht wie Text aus, bis der
   Nutzer hineinklickt.
   ---------------------------------------------------------- */
.inp-name {
    width: 130px;
    font-size: 14px;
    font-weight: 600;
    font-family: 'Inter', sans-serif;
    color: var(--text-primary);
    background: transparent;
    border: 1.5px solid transparent;
    border-radius: 8px;
    padding: 4px 8px;
    outline: none;
    transition: var(--transition);
    cursor: text;
    flex-shrink: 0;
}

/* Im Fokus: sichtbarer Rahmen ‚Üí zeigt an, dass es editierbar ist */
.inp-name:focus {
    border-color: var(--accent);
    background: rgba(255,255,255,0.85);
    box-shadow: 0 0 0 3px var(--accent-soft);
}

/* Hover-Hinweis: gestrichelter Rahmen */
.inp-name:hover:not(:focus) {
    border-color: rgba(0,0,0,0.15);
    background: rgba(255,255,255,0.5);
}

body.dark .inp-name:focus    { background: rgba(255,255,255,0.08); }
body.dark .inp-name:hover:not(:focus) { border-color: rgba(255,255,255,0.15); }

/* ----------------------------------------------------------
   SEGMENT-SYSTEM
   Jede Variante kann N benannte Segmente haben (z. B.
   Produktgruppen). Segmente werden unterhalb der Haupt-Zeile
   einer Variante in einer ausklappbaren Area angezeigt.
   ---------------------------------------------------------- */

/* Container f√ºr alle Segmente einer Variante */
.segment-area {
    margin-top: 8px;
    padding: 12px 16px 12px 36px; /* Links einger√ºckt (unter dem Dot) */
    background: rgba(0,0,0,0.025);
    border-radius: var(--radius-md);
    border: 1.5px dashed rgba(0,0,0,0.08);
    display: none; /* standardm√§√üig eingeklappt */
}

.segment-area.open { display: block; }

body.dark .segment-area {
    background: rgba(255,255,255,0.03);
    border-color: rgba(255,255,255,0.08);
}

/* √úberschrift der Segment-Area */
.segment-area-title {
    font-size: 11px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.7px;
    color: var(--text-muted);
    margin-bottom: 10px;
}

/* Einzelne Segment-Zeile */
.segment-row {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 8px;
    flex-wrap: wrap;
}

.segment-row:last-of-type { margin-bottom: 0; }

/* Name des Segments (z. B. "Elektronik") */
.inp-segment-name {
    width: 140px;
    font-size: 13px;
    font-family: 'Inter', sans-serif;
    color: var(--text-primary);
    background: rgba(255,255,255,0.75);
    border: 1.5px solid rgba(0,0,0,0.08);
    border-radius: 8px;
    padding: 6px 10px;
    outline: none;
    transition: var(--transition);
}

.inp-segment-name:focus {
    border-color: var(--accent);
    box-shadow: 0 0 0 3px var(--accent-soft);
}

body.dark .inp-segment-name {
    background: rgba(255,255,255,0.06);
    border-color: rgba(255,255,255,0.1);
    color: var(--text-primary);
}

/* Kleiner Entfernen-Button f√ºr einzelne Segment-Zeile */
.btn-remove-seg {
    background: transparent;
    border: none;
    color: var(--text-muted);
    cursor: pointer;
    padding: 3px 6px;
    border-radius: 6px;
    font-size: 13px;
    transition: var(--transition);
}

.btn-remove-seg:hover { color: var(--danger); background: var(--danger-soft); }

/* Toggle-Button zum Auf-/Zuklappen der Segment-Area */
.btn-toggle-seg {
    background: transparent;
    border: 1.5px solid rgba(0,0,0,0.10);
    color: var(--text-muted);
    cursor: pointer;
    padding: 4px 10px;
    border-radius: 8px;
    font-size: 12px;
    font-family: 'Inter', sans-serif;
    font-weight: 500;
    transition: var(--transition);
    margin-left: auto; /* rechtsb√ºndig in der Varianten-Zeile */
}

.btn-toggle-seg:hover  { border-color: var(--accent); color: var(--accent); }
body.dark .btn-toggle-seg { border-color: rgba(255,255,255,0.12); }

/* Live-CR-Anzeige f√ºr einzelne Segment-Zeile */
.segment-rate {
    font-family: 'IBM Plex Mono', monospace;
    font-size: 12px;
    color: var(--accent);
    min-width: 48px;
    font-weight: 500;
}

/* ----------------------------------------------------------
   ERGEBNIS-TABS ‚Äì Tab-Navigation
   Ein Tab pro Analyse-Box. Aktiver Tab hervorgehoben.
   ---------------------------------------------------------- */
.tab-bar {
    display: flex;
    gap: 6px;
    flex-wrap: wrap;
    margin-bottom: 16px;
    padding-bottom: 12px;
    border-bottom: 1.5px solid rgba(0,0,0,0.07);
}

body.dark .tab-bar { border-color: rgba(255,255,255,0.08); }

.tab-btn {
    padding: 5px 16px;
    border-radius: 10px;
    border: 1.5px solid rgba(0,0,0,0.10);
    background: transparent;
    color: var(--text-secondary);
    font-size: 13px;
    font-weight: 500;
    font-family: 'Inter', sans-serif;
    cursor: pointer;
    transition: var(--transition);
}

.tab-btn:hover {
    border-color: var(--accent);
    color: var(--accent);
}

.tab-btn.active {
    background: var(--accent);
    border-color: var(--accent);
    color: white;
}

body.dark .tab-btn { border-color: rgba(255,255,255,0.12); }

/* Panel-Inhalte ‚Äì nur aktives Panel sichtbar */
.tab-panel {
    display: none;
}

.tab-panel.active { display: block; }

/* Live-Uplift neben der CR-Anzeige in der Eingabezeile */
.variant-uplift {
    font-family: 'IBM Plex Mono', monospace;
    font-size: 12px;
    font-weight: 600;
    padding: 2px 7px;
    border-radius: 20px;
    white-space: nowrap;
}
.variant-uplift.pos { background: var(--success-soft); color: var(--success); }
.variant-uplift.neg { background: var(--danger-soft);  color: var(--danger); }
.variant-uplift.hidden { display: none; }

/* Kompaktere Ergebnis-Panels */
.glass.result-panel {
    padding: 20px 24px;
    margin-bottom: 16px;
}

.section-title {
    font-size: 14px;
    font-weight: 600;
    color: var(--text-primary);
    margin-bottom: 12px;
    display: flex;
    align-items: center;
    gap: 8px;
}

.metric-card {
    background: rgba(255,255,255,0.5);
    border-radius: var(--radius-md);
    padding: 12px 16px;
    border: 1.5px solid rgba(255,255,255,0.9);
}

.metric-value {
    font-size: 20px;
    font-weight: 600;
    font-family: 'IBM Plex Mono', monospace;
    color: var(--text-primary);
}

.ci-entry {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 9px 14px;
    border-radius: var(--radius-sm);
    margin-bottom: 7px;
    background: rgba(255,255,255,0.45);
    border: 1.5px solid rgba(255,255,255,0.7);
    gap: 12px;
    flex-wrap: wrap;
}

.ci-entry:last-of-type { margin-bottom: 0; }

.grid-3 {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 10px;
    margin-bottom: 16px;
}

.grid-2 {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 16px;
}

.decision-box {
    border-radius: var(--radius-md);
    padding: 20px 24px;
    margin-bottom: 16px;
    font-size: 14px;
    line-height: 1.65;
    border: 2px solid transparent;
}

/* ----------------------------------------------------------
   7. Animationen
   ---------------------------------------------------------- */
@keyframes spin {
    to { transform: rotate(360deg); }
}

@keyframes fadeInUp {
    from { opacity: 0; transform: translateY(16px); }
    to   { opacity: 1; transform: translateY(0);     }
}

/* Ergebnis-Panels erscheinen nacheinander */
.result-panel {
    animation: fadeInUp 0.4s ease both;
}

/* Verz√∂gerung pro Panel ‚Äì wird per data-Attribut angewendet */
.result-panel:nth-child(1) { animation-delay: 0.05s; }
.result-panel:nth-child(2) { animation-delay: 0.12s; }
.result-panel:nth-child(3) { animation-delay: 0.19s; }
.result-panel:nth-child(4) { animation-delay: 0.26s; }
.result-panel:nth-child(5) { animation-delay: 0.33s; }

</style>
</head>

<!-- ============================================================
     HTML-STRUKTUR
     ============================================================ -->
<body class="light">

<!-- ‚îÄ‚îÄ Header ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
<div class="page-header">
    <div>
        <h1 class="page-title">A/B Test Auswertung</h1>
        <p class="page-subtitle">Bayesianische Analyse ¬∑ Beta-Posterior</p>
    </div>
    <div style="display:flex; gap:10px; align-items:center;">
        <button class="toggle-btn" onclick="openSettings()" title="Einstellungen √∂ffnen">Einstellungen</button>
        <button class="toggle-btn" onclick="toggleMode()">üåó Dark Mode</button>
    </div>
</div>

<!-- ‚îÄ‚îÄ Settings-Modal ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
<div id="settingsOverlay" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,0.25); z-index:1000;" onclick="closeSettings(event)">
    <div id="settingsModal" style="position:absolute; top:72px; right:64px; background:#ffffff; border:1px solid rgba(0,0,0,0.10); border-radius:var(--radius-lg); padding:28px; min-width:320px; box-shadow:0 8px 32px rgba(0,0,0,0.15); color:var(--text-primary);" onclick="event.stopPropagation()">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:20px;">
            <span style="font-size:15px; font-weight:600; color:#1c1917;">Einstellungen</span>
            <button onclick="closeSettings()" style="background:none; border:none; cursor:pointer; font-size:18px; color:#a8a29e; line-height:1; padding:2px 6px;">‚úï</button>
        </div>
        <div style="display:flex; flex-direction:column; gap:14px;">
            <div class="input-group">
                <label style="color:#57534e;">Prior Œ± (Alpha)</label>
                <input type="number" id="priorA" value="1" min="0.1" step="0.1" style="width:100%; background:#f5f5f4; border-color:rgba(0,0,0,0.12); color:#1c1917;">
            </div>
            <div class="input-group">
                <label style="color:#57534e;">Prior Œ≤ (Beta)</label>
                <input type="number" id="priorB" value="1" min="0.1" step="0.1" style="width:100%; background:#f5f5f4; border-color:rgba(0,0,0,0.12); color:#1c1917;">
            </div>
            <div class="input-group">
                <label style="color:#57534e;">Entscheidungsgrenze (%)</label>
                <input type="number" id="threshold" value="95" min="50" max="100" step="1" style="width:100%; background:#f5f5f4; border-color:rgba(0,0,0,0.12); color:#1c1917;">
            </div>
            <div class="input-group">
                <label style="color:#57534e;">Credible Interval (%)</label>
                <input type="number" id="ciLevel" value="95" min="50" max="99" step="1" style="width:100%; background:#f5f5f4; border-color:rgba(0,0,0,0.12); color:#1c1917;">
            </div>
            <div class="input-group">
                <label style="color:#57534e;">Simulationen</label>
                <input type="number" id="numSamples" value="50000" min="1000" max="100000" step="1000" style="width:100%; background:#f5f5f4; border-color:rgba(0,0,0,0.12); color:#1c1917;">
            </div>
            <p style="font-size:12px; color:#a8a29e; margin-top:2px; line-height:1.5;">
                Prior Œ±=1, Œ≤=1 = uninformativer Prior.<br>H√∂here Werte regularisieren zur Mitte.
            </p>
        </div>
    </div>
</div>

<!-- ‚îÄ‚îÄ Analyse-Boxen ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
     Jede Box steht f√ºr einen Auswertungskontext (z. B. "Gesamt",
     "Elektronik", "Mobile-Nutzer"). Die erste Box ist nicht
     l√∂schbar. Weitere Boxen werden per Button hinzugef√ºgt.
     ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
<div id="analysis-boxes"></div>

<!-- Button: neue Analyse-Box hinzuf√ºgen -->
<div style="margin-bottom: var(--gap);">
    <button class="btn btn-ghost" onclick="addAnalysisBox()">
        + Segment / Analyse-Box hinzuf√ºgen
    </button>
</div>

<!-- (Advanced Settings wurde als Zahnrad-Modal ins Header verschoben) -->

<!-- ‚îÄ‚îÄ Globale Fehlermeldung ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
<div id="validationAlert" class="alert error" style="margin-bottom: var(--gap);"></div>

<!-- ‚îÄ‚îÄ Analyse-Button + Lade-Spinner ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
<div class="glass" style="display:flex; align-items:center; gap:20px; flex-wrap:wrap;">
    <button class="btn" onclick="runTest()">
        ‚ñ∂ Analyse starten
    </button>
    <div class="spinner-overlay" id="spinner">
        <div class="spinner"></div>
        <span>Berechne Posterioren‚Ä¶</span>
    </div>
    <button class="btn btn-ghost" onclick="saveAsHTML()" title="Aktuelle Eingaben als HTML-Datei speichern">
        üíæ Als HTML speichern
    </button>
</div>

<!-- ‚îÄ‚îÄ Ergebnis-Container (wird per JS bef√ºllt) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
<div id="results"></div>


<!-- ============================================================
     JAVASCRIPT
     Aufgeteilt in Sektionen:
       A. Konstanten & State
       B. Dark Mode & Initialisierung
       C. Varianten-Verwaltung
       D. Input-Validierung
       E. URL-State (Teilen / Laden)
       F. Sampling-Algorithmen (Beta, Gamma, Normal)
       G. Web Worker (Sampling im Hintergrund-Thread)
       H. Statistische Hilfsfunktionen
       I. Analyse-Orchestrierung (runTest)
       J. Render-Funktionen (renderResults + Sub-Renderer)
       K. Export-Funktion (CSV)
     ============================================================ -->
<script>

// ============================================================
// A. KONSTANTEN & STATE
// ============================================================

/**
 * Farbpalette f√ºr bis zu 5 Varianten.
 * Wird in jeder Analyse-Box f√ºr dieselben Varianten-Positionen
 * konsistent verwendet (Control = Indigo, Var 1 = Orange, ‚Ä¶).
 */
const VARIANT_COLORS = ['#5b6cf9', '#f97316', '#22c55e', '#ec4899', '#a855f7'];

/**
 * Globaler State ‚Äì wird nach jeder Analyse bef√ºllt
 * und von CSV-Export und Share-URL genutzt.
 */
let lastResults = null;

/**
 * Laufender Z√§hler f√ºr eindeutige Box-IDs.
 * Wird bei addAnalysisBox() hochgez√§hlt und nie zur√ºckgesetzt,
 * damit IDs auch nach dem Entfernen von Boxen eindeutig bleiben.
 */
let boxCounter = 0;


// ============================================================
// B. DARK MODE & INITIALISIERUNG
// ============================================================

/** Schaltet zwischen Light- und Dark-Mode um. */
function toggleMode() {
    document.body.classList.toggle('dark');
    document.body.classList.toggle('light');
}

/**
 * Beim Seitenstart:
 *  ‚Äì data-snapshot auf <body> vorhanden ‚Üí gespeicherten Zustand wiederherstellen
 *  ‚Äì Sonst ‚Üí leere Erstbox ("Gesamt") anlegen
 */
(function init() {
    const raw = document.body.dataset.snapshot;
    if (raw) {
        try {
            const parsed = JSON.parse(raw);
            // Strukturvalidierung: snapshot muss Array sein, settings ein Objekt
            if (!Array.isArray(parsed.snapshot) || typeof parsed.settings !== 'object') {
                throw new Error('Ung√ºltige Snapshot-Struktur');
            }
            const { snapshot, settings } = parsed;
            // Einstellungen setzen
            if (settings) {
                document.getElementById('priorA').value     = +settings.priorA     || 1;
                document.getElementById('priorB').value     = +settings.priorB     || 1;
                document.getElementById('threshold').value  = +settings.threshold  || 95;
                document.getElementById('ciLevel').value    = +settings.ciLevel    || 95;
                document.getElementById('numSamples').value = +settings.numSamples || 50000;
            }
            // Boxen aufbauen ‚Äì max. 20 Boxen, max. 10 Varianten pro Box
            snapshot.slice(0, 20).forEach((boxData, bi) => {
                if (!Array.isArray(boxData.variants)) return;
                const colLabels = Array.isArray(boxData.colLabels) ? boxData.colLabels : null;
                addAnalysisBox(
                    String(boxData.title || '').slice(0, 100),
                    bi === 0,
                    boxData.variants.slice(0, 10).map(v => ({
                        name:        String(v.name        || '').slice(0, 100),
                        visitors:    parseInputNumber(v.visitors)    || 1000,
                        conversions: parseInputNumber(v.conversions) || 100
                    })),
                    colLabels
                );
            });
            return;
        } catch(e) {
            console.warn('Snapshot konnte nicht geladen werden:', e);
        }
    }
    // Standard: leere Gesamt-Box
    addAnalysisBox('Gesamt', true);
})();


// ============================================================
// C. ANALYSE-BOXEN-VERWALTUNG
// ============================================================

/**
 * F√ºgt eine neue Analyse-Box in #analysis-boxes ein.
 * Beim Anlegen einer Nicht-Haupt-Box werden Namen und Zahlen
 * aus der ersten Box √ºbernommen (au√üer explizit anders angegeben).
 *
 * @param {string}  title    - Vorausgef√ºllter Titel
 * @param {boolean} isMain   - true ‚Üí nicht l√∂schbar, Badge "Gesamt"
 * @param {Array}   variants - Optionales Array [{name,visitors,conversions}] zum Vorausf√ºllen
 */
function addAnalysisBox(title = 'Neues Segment', isMain = false, variants = null, colLabels = null) {
    const container = document.getElementById('analysis-boxes');
    const boxId     = ++boxCounter;
    const varId     = `variants-${boxId}`;

    const box = document.createElement('div');
    box.className      = 'analysis-box';
    box.dataset.boxId  = boxId;

    box.innerHTML = `
        <div class="analysis-box-header">
            <input type="text"
                   class="inp-box-title"
                   value="${escapeHTML(title)}"
                   placeholder="Name des Segments">
            <span class="box-type-badge ${isMain ? 'main' : 'segment'}">
                ${isMain ? 'Gesamt' : 'Segment'}
            </span>
            ${!isMain ? '<button class="btn-remove-box" title="Diese Analyse-Box entfernen">‚úï Entfernen</button>' : ''}
        </div>
        <div id="${varId}"></div>
        <div style="margin-top:12px;">
            <button class="btn btn-ghost btn-add-variant" style="font-size:13px;">
                + Variante hinzuf√ºgen
            </button>
        </div>
    `;

    container.appendChild(box);

    // Event-Listener nach dem Einf√ºgen setzen ‚Äì kein inline-onclick
    if (!isMain) {
        box.querySelector('.btn-remove-box').addEventListener('click', () => box.remove());
    }
    box.querySelector('.btn-add-variant').addEventListener('click', () => addVariantToBox(varId));

    // Spaltenbeschriftungen ermitteln:
    // 1) Aus Parameter (Snapshot-Laden)
    // 2) Aus erster Box (beim manuellen Hinzuf√ºgen eines Segments)
    // 3) Default ['Besucher','Conversions']
    let effectiveColLabels = colLabels;
    if (!effectiveColLabels && !isMain) {
        const firstBox = document.querySelector('.analysis-box');
        if (firstBox) {
            const hdr = firstBox.querySelector('.variant-col-header');
            if (hdr) {
                const cols = hdr.querySelectorAll('.col-label-input');
                effectiveColLabels = Array.from(cols).map(el => el.value);
            }
        }
    }

    if (variants && variants.length > 0) {
        variants.forEach((v, i) => {
            addVariantToBox(varId, i === 0, v.visitors, v.conversions, v.name, effectiveColLabels, i === 0);
        });
    } else if (isMain) {
        addVariantToBox(varId, true,  1000, 100, '', effectiveColLabels, true);
        addVariantToBox(varId, false, 1000, 100, '', effectiveColLabels, false);
    } else {
        const firstBox = document.querySelector('.analysis-box');
        if (firstBox) {
            const firstRows = firstBox.querySelectorAll('.variant-row');
            firstRows.forEach((row, i) => {
                const name        = row.querySelector('.inp-name')?.value || '';
                const visitors    = parseInputNumber(row.querySelector('.inp-visitors')?.value) || 1000;
                const conversions = parseInputNumber(row.querySelector('.inp-conversions')?.value) || 100;
                addVariantToBox(varId, i === 0, visitors, conversions, name, effectiveColLabels, i === 0);
            });
        } else {
            addVariantToBox(varId, true,  1000, 100, '', effectiveColLabels, true);
            addVariantToBox(varId, false, 1000, 100, '', effectiveColLabels, false);
        }
    }
}

/**
 * F√ºgt eine Varianten-Zeile als Tabellenzeile ein.
 * Die erste Zeile (isFirst=true) enth√§lt einen editierbaren Spaltenkopf.
 *
 * @param {string}  varContainerId
 * @param {boolean} isControl
 * @param {number}  visitors
 * @param {number}  conversions
 * @param {string}  name
 * @param {Array}   colLabels - ['Besucher','Conversions'] oder null f√ºr Default
 * @param {boolean} isFirst   - true = Spaltenkopf-Zeile voranstellen
 */
function addVariantToBox(varContainerId, isControl = false, visitors = 1000, conversions = 100, name = '', colLabels = null, isFirst = false) {
    const container   = document.getElementById(varContainerId);
    if (!container) return;

    const index       = container.querySelectorAll('.variant-row').length;
    const color       = VARIANT_COLORS[index % VARIANT_COLORS.length];
    const defaultName = isControl ? 'Control' : `Variante ${index}`;
    const displayName = name || defaultName;
    const uid         = `${varContainerId}_${Date.now()}_${index}`;

    const lbl0 = (colLabels && colLabels[0]) || 'Besucher';
    const lbl1 = (colLabels && colLabels[1]) || 'Conversions';

    // Spaltenk√∂pfe ‚Äì nur √ºber der ersten Zeile
    if (isFirst) {
        // Eventuell vorhandenen alten Header entfernen
        const oldHdr = container.querySelector('.variant-col-header');
        if (oldHdr) oldHdr.remove();

        const hdr = document.createElement('div');
        hdr.className = 'variant-col-header';
        hdr.innerHTML = `
            <div class="col-spacer"></div>
            <div class="col-spacer-name"></div>
            <input class="col-label-input" type="text" value="${escapeHTML(lbl0)}" title="Spaltenbeschriftung bearbeiten">
            <input class="col-label-input" type="text" value="${escapeHTML(lbl1)}" title="Spaltenbeschriftung bearbeiten">
            <div class="col-spacer-cr">CR / Œî</div>
        `;
        container.appendChild(hdr);
    }

    const row = document.createElement('div');
    row.className     = 'variant-row';
    row.dataset.uid   = uid;
    row.dataset.color = color;
    row.dataset.isControl = isControl ? '1' : '0';

    row.innerHTML = `
        <div class="variant-dot" style="background:${color};"></div>
        <input type="text" class="inp-name"
               value="${escapeHTML(displayName)}"
               placeholder="${escapeHTML(defaultName)}"
               title="Namen bearbeiten">
        <input type="text" inputmode="numeric" class="inp-visitors" value="${visitors}">
        <input type="text" inputmode="numeric" class="inp-conversions" value="${conversions}">
        <div class="variant-cr-cell">
            <span class="variant-rate" id="rate-${uid}">${(conversions / visitors * 100).toFixed(2)}%</span>
            <span class="variant-uplift hidden" id="uplift-${uid}"></span>
        </div>
        ${!isControl ? '<button class="btn-remove" title="Variante entfernen">‚úï</button>' : '<div class="btn-remove-placeholder"></div>'}
    `;

    // Event-Listener via addEventListener (kein inline-onclick)
    row.querySelector('.inp-visitors').addEventListener('input',
        () => updateRate(row));
    row.querySelector('.inp-conversions').addEventListener('input',
        () => updateRate(row));

    if (!isControl) {
        row.querySelector('.btn-remove').addEventListener('click', () => {
            const c = row.closest('[id^="variants-"]');
            row.remove();
            refreshAllUplift(c);
        });
    }

    container.appendChild(row);
    refreshAllUplift(container);
}

/**
 * Parst eine Zahl aus einem Eingabefeld.
 * Akzeptiert Tausenderpunkte: "1.000" ‚Üí 1000, "1.234.567" ‚Üí 1234567.
 * Kommas als Dezimaltrennzeichen werden ebenfalls unterst√ºtzt.
 *
 * @param {string} val - Rohwert aus dem Input
 * @returns {number}
 */
function parseInputNumber(val) {
    if (!val) return NaN;
    // Eingabel√§nge begrenzen um ReDoS zu verhindern
    const raw = String(val).trim().slice(0, 20);
    const cleaned = raw
        .replace(/\.(?=\d{3}(?:[.,]|$))/g, '') // Tausenderpunkte entfernen
        .replace(',', '.');                       // Dezimalkomma ‚Üí Punkt
    return parseFloat(cleaned);
}

/**
 * Aktualisiert CR-Anzeige und Uplift-Badge f√ºr eine einzelne Zeile.
 */
function updateRate(row) {
    const n      = parseInputNumber(row.querySelector('.inp-visitors')?.value)   || 0;
    const c      = parseInputNumber(row.querySelector('.inp-conversions')?.value) || 0;
    const uid    = row.dataset.uid;
    const rateEl = document.getElementById(`rate-${uid}`);
    if (rateEl) {
        rateEl.textContent = n > 0 ? `${(c / n * 100).toFixed(2)}%` : '‚Äì';
    }
    // Uplift aller Zeilen im selben Container aktualisieren
    const container = row.parentElement;
    if (container) refreshAllUplift(container);
}

/**
 * Berechnet und aktualisiert den Uplift-Chip aller Varianten-Zeilen
 * relativ zur ersten Zeile (Control) desselben Containers.
 *
 * @param {HTMLElement} container - Der Varianten-Container (.id starts with "variants-")
 */
function refreshAllUplift(container) {
    if (!container) return;
    const rows = container.querySelectorAll('.variant-row');
    if (rows.length < 1) return;

    // Control-Rate aus erster Zeile
    const cn = parseInputNumber(rows[0].querySelector('.inp-visitors')?.value)   || 0;
    const cc = parseInputNumber(rows[0].querySelector('.inp-conversions')?.value) || 0;
    const controlRate = cn > 0 ? cc / cn : 0;

    rows.forEach((row, i) => {
        const uid      = row.dataset.uid;
        const upliftEl = document.getElementById(`uplift-${uid}`);
        if (!upliftEl) return;

        if (i === 0) {
            // Control: kein Uplift-Badge
            upliftEl.className = 'variant-uplift hidden';
            upliftEl.textContent = '';
            return;
        }

        const n = parseInputNumber(row.querySelector('.inp-visitors')?.value)   || 0;
        const c = parseInputNumber(row.querySelector('.inp-conversions')?.value) || 0;
        if (n <= 0 || controlRate === 0) {
            upliftEl.className = 'variant-uplift hidden';
            return;
        }

        const rate   = c / n;
        const uplift = (rate - controlRate) / controlRate;
        const pct    = (uplift * 100).toFixed(1);
        const sign   = uplift > 0 ? '+' : '';
        upliftEl.textContent = `${sign}${pct}%`;
        upliftEl.className   = `variant-uplift ${uplift > 0 ? 'pos' : uplift < 0 ? 'neg' : 'hidden'}`;
    });
}


// ============================================================
// D. INPUT-VALIDIERUNG
// ============================================================

/**
 * Liest alle Analyse-Boxen und ihre Varianten-Zeilen aus,
 * validiert die Eingaben und gibt ein Array von Analyse-Objekten zur√ºck.
 *
 * R√ºckgabe-Struktur:
 * {
 *   valid: boolean,
 *   analyses?: Array<{
 *     title:    string,       // Titel der Box (z. B. "Gesamt", "Elektronik")
 *     isMain:   boolean,      // true = erste Box
 *     variants: Array<{
 *       label, n, c, color, alpha, beta
 *     }>
 *   }>,
 *   error?: string
 * }
 *
 * M√∂gliche Validierungsfehler:
 *  ‚Äì Weniger als 2 Varianten in einer Box
 *  ‚Äì Conversions > Besucher
 *  ‚Äì Negative oder leere Werte
 */
function parseAndValidate() {
    const boxes  = document.querySelectorAll('.analysis-box');
    const priorA = Math.max(0.1, parseFloat(document.getElementById('priorA').value) || 1);
    const priorB = Math.max(0.1, parseFloat(document.getElementById('priorB').value) || 1);

    if (boxes.length < 1) {
        return { valid: false, error: 'Bitte mindestens eine Analyse-Box bef√ºllen.' };
    }

    const analyses = [];
    let errorMsg   = '';

    boxes.forEach((box, boxIdx) => {
        if (errorMsg) return; // Abbrechen bei erstem Fehler

        // Titel der Box lesen
        const titleInput = box.querySelector('.inp-box-title');
        const title      = (titleInput && titleInput.value.trim()) ||
                           (boxIdx === 0 ? 'Gesamt' : `Segment ${boxIdx}`);
        const isMain     = boxIdx === 0;

        // Alle Varianten-Zeilen dieser Box
        const rows    = box.querySelectorAll('.variant-row');
        const variants = [];

        if (rows.length < 2) {
            errorMsg = `"${title}": Bitte mindestens 2 Varianten (Control + eine Test-Variante) eingeben.`;
            return;
        }
        if (rows.length > 10) {
            errorMsg = `"${title}": Maximal 10 Varianten pro Box erlaubt.`;
            return;
        }

        rows.forEach((row, i) => {
            if (errorMsg) return;

            const nInput    = row.querySelector('.inp-visitors');
            const cInput    = row.querySelector('.inp-conversions');
            const nameInput = row.querySelector('.inp-name');
            const n         = parseInputNumber(nInput.value);
            const c         = parseInputNumber(cInput.value);

            // Custom-Name mit Fallback
            const defaultLabel = i === 0 ? 'Control' : `Variante ${i}`;
            const label        = (nameInput && nameInput.value.trim()) || defaultLabel;

            // Validierung
            nInput.classList.remove('invalid');
            cInput.classList.remove('invalid');

            if (isNaN(n) || n < 1) {
                nInput.classList.add('invalid');
                errorMsg = `"${title}" ‚Ä∫ ${label}: Besucher muss mindestens 1 sein.`;
                return;
            } else if (isNaN(c) || c < 0) {
                cInput.classList.add('invalid');
                errorMsg = `"${title}" ‚Ä∫ ${label}: Conversions darf nicht negativ sein.`;
                return;
            } else if (c > n) {
                cInput.classList.add('invalid');
                errorMsg = `"${title}" ‚Ä∫ ${label}: Conversions (${c}) > Besucher (${n}).`;
                return;
            }

            variants.push({
                label,
                n,
                c,
                color: VARIANT_COLORS[i % VARIANT_COLORS.length],
                // Posterior-Parameter: Prior + beobachtete Daten
                alpha: priorA + c,
                beta:  priorB + n - c
            });
        });

        if (!errorMsg) {
            analyses.push({ title, isMain, variants });
        }
    });

    if (errorMsg) return { valid: false, error: errorMsg };
    return { valid: true, analyses };
}

/** Zeigt oder versteckt die globale Fehler-Alert-Box. */
function showAlert(msg) {
    const el = document.getElementById('validationAlert');
    el.textContent = msg;
    el.classList.toggle('visible', !!msg);
}


// ============================================================
// E. EINSTELLUNGS-MODAL & HTML-EXPORT
// ============================================================

/** √ñffnet das Einstellungs-Modal. */
function openSettings() {
    document.getElementById('settingsOverlay').style.display = 'block';
}

/** Schlie√üt das Einstellungs-Modal (auch bei Klick auf Backdrop). */
function closeSettings(event) {
    if (!event || event.target === document.getElementById('settingsOverlay')) {
        document.getElementById('settingsOverlay').style.display = 'none';
    }
}

// Schlie√üen mit Escape-Taste
document.addEventListener('keydown', e => {
    if (e.key === 'Escape') closeSettings();
});

/**
 * Speichert die aktuelle Konfiguration als eigenst√§ndige HTML-Datei.
 *
 * Vorgehen:
 *  1. Aktuellen Zustand (Box-Titel, Varianten, Einstellungen) als JSON erfassen.
 *  2. Den HTML-Quelltext der ORIGINALEN Seite nehmen ‚Äì dabei die dynamisch
 *     erzeugten Container (#analysis-boxes, #results) leeren, damit beim
 *     √ñffnen der gespeicherten Datei kein doppelter DOM entsteht.
 *  3. Den Snapshot als data-Attribut auf <body> einbetten.
 *  4. init() liest dieses Attribut beim Start und baut alles neu auf.
 */
function saveAsHTML() {
    // ‚îÄ‚îÄ 1. Zustand serialisieren ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    const boxes = document.querySelectorAll('.analysis-box');
    const snapshot = [];

    boxes.forEach((box, bi) => {
        const title  = box.querySelector('.inp-box-title')?.value || '';
        const isMain = bi === 0;
        const rows   = box.querySelectorAll('.variant-row');

        const hdr       = box.querySelector('.variant-col-header');
        const colInputs = hdr ? hdr.querySelectorAll('.col-label-input') : [];
        const colLabels = colInputs.length >= 2
            ? [colInputs[0].value, colInputs[1].value]
            : ['Besucher', 'Conversions'];

        const varData = [];
        rows.forEach((row, ri) => {
            varData.push({
                name:        row.querySelector('.inp-name')?.value        || '',
                visitors:    row.querySelector('.inp-visitors')?.value    || '1000',
                conversions: row.querySelector('.inp-conversions')?.value || '100',
                isControl:   ri === 0
            });
        });
        snapshot.push({ title, isMain, colLabels, variants: varData });
    });

    const settings = {
        priorA:     document.getElementById('priorA').value,
        priorB:     document.getElementById('priorB').value,
        threshold:  document.getElementById('threshold').value,
        ciLevel:    document.getElementById('ciLevel').value,
        numSamples: document.getElementById('numSamples').value
    };

    // ‚îÄ‚îÄ 2. Sauberes HTML-Skelett erzeugen ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // Dynamisch erzeugte Inhalte tempor√§r leeren (synchron, kein Race-Condition-Risiko),
    // damit outerHTML keine doppelten Eingabefelder oder Ergebnis-Panels enth√§lt.
    const analysisBoxesEl = document.getElementById('analysis-boxes');
    const resultsEl       = document.getElementById('results');
    const savedBoxes      = analysisBoxesEl.innerHTML;
    const savedResults    = resultsEl.innerHTML;
    const savedSnapshot   = document.body.dataset.snapshot || '';

    let html;
    try {
        analysisBoxesEl.innerHTML = '';
        resultsEl.innerHTML       = '';
        delete document.body.dataset.snapshot;

        // ‚îÄ‚îÄ 3. Snapshot einbetten ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        const payload = JSON.stringify({ snapshot, settings });
        document.body.dataset.snapshot = payload;

        html = '<!DOCTYPE html>\n' + document.documentElement.outerHTML;
    } finally {
        // DOM immer wiederherstellen ‚Äì auch bei unerwarteten Fehlern
        analysisBoxesEl.innerHTML = savedBoxes;
        resultsEl.innerHTML       = savedResults;
        if (savedSnapshot) {
            document.body.dataset.snapshot = savedSnapshot;
        } else {
            delete document.body.dataset.snapshot;
        }
    }

    // ‚îÄ‚îÄ 4. Download triggern ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    const blob = new Blob([html], { type: 'text/html;charset=utf-8' });
    const url  = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href     = url;
    link.download = `ab_test_${new Date().toISOString().slice(0, 10)}.html`;
    link.click();
    URL.revokeObjectURL(url);
}

/** Escapet einen String f√ºr sicheres Einbetten in ein HTML-Attribut. */
function escapeAttr(str) {
    return String(str)
        .replace(/&/g, '&amp;')
        .replace(/"/g, '&quot;');
}


// ============================================================
// F. SAMPLING-ALGORITHMEN
// ============================================================

/**
 * Box-Muller-Transformation: liefert eine standard-normalverteilte Zufallszahl.
 * Wird f√ºr die Gamma-Approximation ben√∂tigt.
 */
function normalSample() {
    let u = 0, v = 0;
    while (u === 0) u = Math.random();
    while (v === 0) v = Math.random();
    return Math.sqrt(-2 * Math.log(u)) * Math.cos(2 * Math.PI * v);
}

/**
 * Marsaglia-Tsang-Algorithmus f√ºr Gamma(s, 1)-Samples.
 * Ben√∂tigt s > 1; f√ºr s < 1 wird ein Trick angewendet (siehe betaSample).
 *
 * @param {number} s - Shape-Parameter
 * @returns {number}
 */
function gammaSample(s) {
    if (s < 1) {
        // F√ºr s < 1: Gamma(s) = Gamma(s+1) * U^(1/s)
        return gammaSample(s + 1) * Math.pow(Math.random(), 1 / s);
    }
    const d = s - 1 / 3;
    const c = 1 / Math.sqrt(9 * d);
    while (true) {
        let x = normalSample();
        let v = Math.pow(1 + c * x, 3);
        if (v > 0) {
            const u = Math.random();
            if (u < 1 - 0.0331 * Math.pow(x, 4) ||
                Math.log(u) < 0.5 * x * x + d * (1 - v + Math.log(v))) {
                return d * v;
            }
        }
    }
}

/**
 * Zieht einen Beta(a, b)-Sample √ºber zwei Gamma-Samples.
 * Beta(a,b) = Gamma(a) / (Gamma(a) + Gamma(b))
 *
 * @param {number} a - Alpha-Parameter
 * @param {number} b - Beta-Parameter
 * @returns {number} - Wert in [0, 1]
 */
function betaSample(a, b) {
    const x = gammaSample(a);
    const y = gammaSample(b);
    return x / (x + y);
}


// ============================================================
// G. WEB WORKER (Sampling im Hintergrund-Thread)
// ============================================================

/**
 * F√ºhrt das Beta-Sampling f√ºr alle Varianten in einem Web Worker aus,
 * damit der UI-Thread nicht blockiert wird (kein "Freezing" des Browsers).
 *
 * Technik: Der Worker-Code wird als Blob-URL erzeugt (kein separates .js-File n√∂tig).
 *
 * @param {Array}  variants   - Array von { alpha, beta, label }
 * @param {number} numSamples - Anzahl der Monte-Carlo-Draws
 * @returns {Promise<Float32Array[]>} - Array von Posterior-Sample-Arrays
 */
function samplePosteriorsInWorker(variants, numSamples) {
    return new Promise((resolve, reject) => {

        // Worker-Code als String ‚Äì enth√§lt die Sampling-Funktionen und die Haupt-Logik
        const workerCode = `
            // --- Sampling-Funktionen (Kopie aus dem Haupt-Thread) ---
            function normalSample() {
                let u = 0, v = 0;
                while (u === 0) u = Math.random();
                while (v === 0) v = Math.random();
                return Math.sqrt(-2 * Math.log(u)) * Math.cos(2 * Math.PI * v);
            }
            function gammaSample(s) {
                if (s < 1) return gammaSample(s + 1) * Math.pow(Math.random(), 1 / s);
                const d = s - 1/3, c = 1 / Math.sqrt(9 * d);
                while (true) {
                    let x = normalSample(), v = Math.pow(1 + c * x, 3);
                    if (v > 0) {
                        const u = Math.random();
                        if (u < 1 - 0.0331 * x**4 || Math.log(u) < 0.5 * x*x + d*(1 - v + Math.log(v)))
                            return d * v;
                    }
                }
            }
            function betaSample(a, b) {
                const x = gammaSample(a), y = gammaSample(b);
                return x / (x + y);
            }

            // --- Hauptlogik des Workers ---
            self.onmessage = function(e) {
                const { variants, numSamples } = e.data;

                // F√ºr jede Variante ein Float32Array mit numSamples Draws
                const posteriors = variants.map(v => {
                    const arr = new Float32Array(numSamples);
                    for (let i = 0; i < numSamples; i++) {
                        arr[i] = betaSample(v.alpha, v.beta);
                    }
                    return arr;
                });

                // Ergebnis zur√ºck an den Haupt-Thread senden
                // Transferable Objects vermeiden Kopier-Overhead f√ºr gro√üe Arrays
                self.postMessage(
                    { posteriors },
                    posteriors.map(p => p.buffer)
                );
            };
        `;

        // Worker via Blob-URL starten
        const blob      = new Blob([workerCode], { type: 'application/javascript' });
        const workerURL = URL.createObjectURL(blob);
        const worker    = new Worker(workerURL);

        worker.onmessage = (e) => {
            URL.revokeObjectURL(workerURL); // Speicher freigeben
            resolve(e.data.posteriors);
        };

        worker.onerror = (err) => {
            URL.revokeObjectURL(workerURL);
            reject(err);
        };

        worker.postMessage({ variants, numSamples });
    });
}


// ============================================================
// H. STATISTISCHE HILFSFUNKTIONEN
// ============================================================

/**
 * Berechnet ein Quantil eines Float32Array.
 * Sortiert das Array einmalig ‚Äì f√ºr mehrere Quantile effizienter
 * als mehrfach zu sortieren.
 *
 * @param {Float32Array} arr - Sample-Array
 * @param {number}       p   - Quantil in [0, 1]
 * @returns {number}
 */
function quantile(arr, p) {
    const sorted = Float32Array.from(arr).sort();
    const idx    = Math.min(Math.floor(p * sorted.length), sorted.length - 1);
    return sorted[idx];
}

/**
 * Berechnet das Highest Density Interval (HDI) ‚Äì den schmalsten
 * Bereich, der (1-alpha)% der Posterior-Masse enth√§lt.
 *
 * Algorithmus: Sliding-Window √ºber sortiertes Array.
 *
 * @param {Float32Array} arr      - Sample-Array
 * @param {number}       credMass - Anteil in [0, 1], z. B. 0.95
 * @returns {{ lower: number, upper: number }}
 */
function hdi(arr, credMass) {
    const sorted    = Array.from(arr).sort((a, b) => a - b);
    const n         = sorted.length;
    const width     = Math.floor(credMass * n); // Anzahl Samples im Intervall
    let minWidth    = Infinity;
    let lowerIdx    = 0;

    // Engsten Window suchen, der genug Samples enth√§lt
    for (let i = 0; i <= n - width; i++) {
        const intervalWidth = sorted[i + width - 1] - sorted[i];
        if (intervalWidth < minWidth) {
            minWidth = intervalWidth;
            lowerIdx = i;
        }
    }

    return {
        lower: sorted[lowerIdx],
        upper: sorted[lowerIdx + width - 1]
    };
}

/**
 * Kernel Density Estimator (KDE) mit Gauss-Kernel.
 * Transformiert ein Sample-Array in eine glatte Dichtefunktion.
 *
 * @param {number[]} sample    - Datenpunkte (in Prozent)
 * @param {number}   bandwidth - Gl√§ttungsparameter
 * @param {number}   points    - Aufl√∂sung der Kurve
 * @returns {{ xs: number[], ys: number[] }}
 */
function kernelDensityEstimator(sample, bandwidth = 0.15, points = 250) {
    const min  = Math.min(...sample);
    const max  = Math.max(...sample);
    const step = (max - min) / points;
    const xs   = [];
    const ys   = [];
    const norm = 1 / (sample.length * bandwidth * Math.sqrt(2 * Math.PI));

    for (let i = 0; i <= points; i++) {
        const x = min + i * step;
        let sum = 0;
        for (let j = 0; j < sample.length; j++) {
            const u = (x - sample[j]) / bandwidth;
            sum    += Math.exp(-0.5 * u * u);
        }
        xs.push(x);
        ys.push(sum * norm);
    }
    return { xs, ys };
}

/**
 * Berechnet den Expected Loss f√ºr jede Variante.
 * Der Expected Loss ist der erwartete entgangene Gewinn,
 * wenn man diese Variante w√§hlt und sie nicht die Beste ist.
 *
 * E[Loss_i] = E[max_k(Œ∏_k) - Œ∏_i]
 *
 * @param {Float32Array[]} posteriors - Posterior-Sample-Arrays
 * @param {number}         n          - Anzahl Samples
 * @returns {number[]} - Expected Loss pro Variante (als Anteil, nicht %)
 */
function calcExpectedLoss(posteriors, n) {
    const losses = new Array(posteriors.length).fill(0);

    for (let j = 0; j < n; j++) {
        // Bestes Sample in diesem Draw
        let bestVal = -Infinity;
        for (let k = 0; k < posteriors.length; k++) {
            if (posteriors[k][j] > bestVal) bestVal = posteriors[k][j];
        }
        // Verlust f√ºr jede Variante = Differenz zum Besten
        for (let i = 0; i < posteriors.length; i++) {
            losses[i] += bestVal - posteriors[i][j];
        }
    }

    return losses.map(l => l / n);
}


// ============================================================
// I. ANALYSE-ORCHESTRIERUNG
// ============================================================

/**
 * Hauptfunktion ‚Äì wird durch "Analyse starten" ausgel√∂st.
 *
 * Ablauf:
 *  1. Alle Analyse-Boxen validieren
 *  2. Spinner anzeigen
 *  3. Pro Box: Sampling via Web Worker + Statistiken berechnen
 *  4. Alle Ergebnisse rendern (Tab pro Box)
 *
 * @returns {Promise<void>}
 */
async function runTest() {
    // 1. Validierung ‚Äì liest alle Boxen
    const { valid, analyses, error } = parseAndValidate();
    showAlert(error || '');
    if (!valid) return;

    // 2. UI-Feedback
    document.getElementById('spinner').classList.add('active');
    document.getElementById('results').innerHTML = '';

    const numSamples = Math.min(100000, Math.max(1000,
        parseInt(document.getElementById('numSamples').value, 10) || 10000));
    const threshold  = Math.min(0.9999, Math.max(0.5,
        parseFloat(document.getElementById('threshold').value) / 100));
    const ciLevel    = Math.min(0.9999, Math.max(0.5,
        parseFloat(document.getElementById('ciLevel').value) / 100));

    try {
        // 3. F√ºr jede Analyse-Box: unabh√§ngiges Sampling + Stats
        const boxResults = [];

        for (const analysis of analyses) {
            const posteriors = await samplePosteriorsInWorker(analysis.variants, numSamples);
            const stats      = buildStats(analysis.variants, posteriors, numSamples, ciLevel);

            boxResults.push({
                title:     analysis.title,
                isMain:    analysis.isMain,
                stats,
                posteriors
            });
        }

        // Globaler State speichern (f√ºr CSV-Export und Share-URL)
        lastResults = { boxResults, threshold, ciLevel, numSamples };

        // 4. Ergebnisse rendern
        renderResults(lastResults);

    } catch (err) {
        // err.message nur als Text anzeigen ‚Äì nicht via innerHTML
        showAlert('Fehler bei der Berechnung: ' + String(err.message || err).slice(0, 200));
        console.error(err);
    } finally {
        document.getElementById('spinner').classList.remove('active');
    }
}

/**
 * Berechnet alle statistischen Kennzahlen f√ºr eine Analyse-Box.
 * Wiederverwendbar f√ºr beliebige Varianten-Sets.
 *
 * @param {object[]}       variants   - { label, n, c, color, alpha, beta }
 * @param {Float32Array[]} posteriors - Posterior-Sample-Arrays
 * @param {number}         numSamples
 * @param {number}         ciLevel    - z. B. 0.95
 * @returns {object[]}
 */
function buildStats(variants, posteriors, numSamples, ciLevel) {
    // Probability to be Best
    const bestCounts = new Array(variants.length).fill(0);
    for (let j = 0; j < numSamples; j++) {
        let bestIdx = 0, bestVal = posteriors[0][j];
        for (let k = 1; k < posteriors.length; k++) {
            if (posteriors[k][j] > bestVal) { bestVal = posteriors[k][j]; bestIdx = k; }
        }
        bestCounts[bestIdx]++;
    }
    const probBest = bestCounts.map(c => c / numSamples);

    // Probability vs. Control (Index 0)
    const probVsControl = posteriors.map((p, i) => {
        if (i === 0) return null;
        let count = 0;
        for (let j = 0; j < numSamples; j++) {
            if (p[j] > posteriors[0][j]) count++;
        }
        return count / numSamples;
    });

    const losses      = calcExpectedLoss(posteriors, numSamples);
    const controlRate = variants[0].c / variants[0].n;

    return posteriors.map((p, i) => {
        const interval = hdi(p, ciLevel);
        const rate     = variants[i].c / variants[i].n;
        return {
            label:         variants[i].label,
            color:         variants[i].color,
            n:             variants[i].n,
            c:             variants[i].c,
            rate,
            median:        quantile(p, 0.5),
            hdiLower:      interval.lower,
            hdiUpper:      interval.upper,
            probBest:      probBest[i],
            probVsControl: probVsControl[i],
            loss:          losses[i],
            uplift:        i === 0 ? null : (rate - controlRate) / controlRate
        };
    });
}


// ============================================================
// J. RENDER-FUNKTIONEN
// ============================================================

/**
 * Haupt-Render-Funktion.
 *
 * Rendert einen Tab-Container mit einem Tab pro Analyse-Box.
 * Gibt es nur eine Box, wird keine Tab-Leiste gezeigt.
 *
 * @param {object} data - lastResults aus runTest()
 */
function renderResults(data) {
    const { boxResults, threshold, ciLevel } = data;
    const container = document.getElementById('results');
    container.innerHTML = '';

    const hasMultiple = boxResults.length > 1;

    if (hasMultiple) {
        // ‚îÄ‚îÄ Tabs-Wrapper ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        const tabWrapper = document.createElement('div');
        tabWrapper.className = 'glass result-panel';

        // Tab-Leiste
        const tabBar = document.createElement('div');
        tabBar.className = 'tab-bar';
        tabWrapper.appendChild(tabBar);

        boxResults.forEach((box, bi) => {
            // Tab-Button
            const btn = document.createElement('button');
            btn.className   = `tab-btn${bi === 0 ? ' active' : ''}`;
            btn.textContent = box.title;
            btn.onclick     = () => switchTab(bi, tabWrapper);
            tabBar.appendChild(btn);

            // Inhalts-Panel
            const panel = document.createElement('div');
            panel.className = `tab-panel${bi === 0 ? ' active' : ''}`;
            panel.dataset.tabIdx = bi;
            renderAnalysisInto(panel, box.stats, box.posteriors, threshold, ciLevel);
            tabWrapper.appendChild(panel);
        });

        container.appendChild(tabWrapper);

    } else {
        // Nur eine Box ‚Üí kein Tab-UI n√∂tig
        renderAnalysisInto(container, boxResults[0].stats, boxResults[0].posteriors, threshold, ciLevel);
    }

}

/**
 * Schaltet den aktiven Tab im Tab-Wrapper um.
 *
 * @param {number}      idx     - Index des zu aktivierenden Tabs
 * @param {HTMLElement} wrapper - Der Tab-Wrapper-Container
 */
function switchTab(idx, wrapper) {
    wrapper.querySelectorAll('.tab-panel').forEach(p => p.classList.remove('active'));
    wrapper.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));

    const panel = wrapper.querySelector(`[data-tab-idx="${idx}"]`);
    const btns  = wrapper.querySelectorAll('.tab-btn');
    if (panel)     panel.classList.add('active');
    if (btns[idx]) btns[idx].classList.add('active');
}

/**
 * Rendert alle Analyse-Panels in einen Container.
 * Wird f√ºr jeden Tab (bzw. direkt ohne Tabs) aufgerufen.
 */
function renderAnalysisInto(container, stats, posteriors, threshold, ciLevel) {
    renderSummaryMetrics(container, stats);
    renderDensityChart(container, stats, posteriors, ciLevel);
    renderProbabilities(container, stats, threshold);
    renderCredibleIntervals(container, stats, ciLevel);
    renderExpectedLoss(container, stats);
    renderDecision(container, stats, threshold);
}

// ------------------------------------------------------------
// J.1 Zusammenfassende Metriken (Conversion Rates auf einen Blick)
// ------------------------------------------------------------
/**
 * Rendert eine Zeile mit kleinen Metric-Cards,
 * eine pro Variante, mit CR, Besucher, Conversions.
 */
function renderSummaryMetrics(container, stats) {
    const panel = createPanel();

    panel.innerHTML = `
        <div class="section-title">
            √úbersicht
            <span class="tooltip-wrap">
                <span class="tooltip-icon">i</span>
                <span class="tooltip-box">Rohe Eingabedaten mit beobachteten Conversion Rates. Diese sind punktuelle Sch√§tzungen ohne Unsicherheit.</span>
            </span>
        </div>
        <div class="grid-3" id="metricCards"></div>
    `;

    const grid = panel.querySelector('#metricCards');

    stats.forEach((s) => {
        const card = document.createElement('div');
        card.className = 'metric-card';

        // Label ‚Äì Nutzer-String ‚Üí nur via textContent
        const labelEl = document.createElement('div');
        labelEl.className = 'metric-label';
        labelEl.style.color = s.color;       // s.color kommt aus VARIANT_COLORS (hardcoded)
        labelEl.textContent = s.label;        // kein innerHTML, kein escapeHTML n√∂tig

        // Rate
        const valueEl = document.createElement('div');
        valueEl.className = 'metric-value';
        valueEl.textContent = `${(s.rate * 100).toFixed(2)}%`;

        // Conversions / Besucher
        const subEl = document.createElement('div');
        subEl.className = 'metric-sub';
        subEl.textContent = `${s.c.toLocaleString()} / ${s.n.toLocaleString()} Conversions`;

        // Uplift
        const upliftEl = document.createElement('div');
        upliftEl.className = 'metric-sub';
        if (s.uplift !== null) {
            upliftEl.innerHTML = `${formatUplift(s.uplift)} vs. Control`; // formatUplift produziert nur Zahlen+CSS-Klassen, kein Nutzer-Input
        } else {
            upliftEl.textContent = 'Baseline';
        }

        card.appendChild(labelEl);
        card.appendChild(valueEl);
        card.appendChild(subEl);
        card.appendChild(upliftEl);
        grid.appendChild(card);
    });

    const exportBtn = document.createElement('button');
    exportBtn.className   = 'btn btn-ghost';
    exportBtn.style.cssText = 'margin-top:20px; font-size:13px;';
    exportBtn.textContent = '‚¨á Ergebnisse als CSV';
    exportBtn.onclick     = exportCSV;
    panel.appendChild(exportBtn);

    container.appendChild(panel);
}

// ------------------------------------------------------------
// J.2 Density-Chart (Plotly)
// ------------------------------------------------------------
/**
 * Rendert die Posterior-Dichteverteilungen als gef√ºllte Linienkurven.
 * Zus√§tzlich werden vertikale Linien f√ºr die HDI-Grenzen eingezeichnet.
 *
 * @param {HTMLElement}    container
 * @param {object[]}       stats
 * @param {Float32Array[]} posteriors
 * @param {number}         ciLevel    - z. B. 0.95
 */
function renderDensityChart(container, stats, posteriors, ciLevel) {
    const panel = createPanel();
    panel.innerHTML = `
        <div class="section-title">
            Posterior-Verteilungen
            <span class="tooltip-wrap">
                <span class="tooltip-icon">i</span>
                <span class="tooltip-box">Jede Kurve zeigt die Wahrscheinlichkeitsverteilung der wahren Conversion Rate. Breite Kurven = hohe Unsicherheit (wenig Daten). Die gestrichelten Linien markieren das ${(ciLevel*100).toFixed(0)}%-HDI.</span>
            </span>
        </div>
        <div id="densityPlot" style="width:100%;min-height:340px;"></div>
    `;
    container.appendChild(panel);

    if (typeof Plotly === 'undefined') return;

    const traces = [];

    posteriors.forEach((p, i) => {
        const s            = stats[i];
        const samplePct    = Array.from(p).map(v => v * 100);
        const density      = kernelDensityEstimator(samplePct, 0.15);

        // Haupt-Dichtefl√§che
        traces.push({
            x:    density.xs,
            y:    density.ys,
            mode: 'lines',
            name: s.label,
            line: { color: s.color, width: 2.5 },
            fill: 'tozeroy',
            fillcolor: hexToRgba(s.color, 0.12),
            type: 'scatter'
        });

        // Vertikale Linie f√ºr HDI-Lower
        traces.push({
            x:    [s.hdiLower * 100, s.hdiLower * 100],
            y:    [0, Math.max(...density.ys) * 0.85],
            mode: 'lines',
            line: { color: s.color, width: 1.5, dash: 'dot' },
            showlegend: false,
            hoverinfo: 'none',
            type: 'scatter'
        });

        // Vertikale Linie f√ºr HDI-Upper
        traces.push({
            x:    [s.hdiUpper * 100, s.hdiUpper * 100],
            y:    [0, Math.max(...density.ys) * 0.85],
            mode: 'lines',
            line: { color: s.color, width: 1.5, dash: 'dot' },
            showlegend: false,
            hoverinfo: 'none',
            type: 'scatter'
        });
    });

    const isDark = document.body.classList.contains('dark');

    Plotly.newPlot(panel.querySelector('#densityPlot'), traces, {
        paper_bgcolor: 'rgba(0,0,0,0)',
        plot_bgcolor:  'rgba(0,0,0,0)',
        margin:  { t: 16, r: 20, b: 50, l: 50 },
        legend:  { orientation: 'h', y: -0.18, font: { size: 12 } },
        xaxis: {
            title:      'Conversion Rate (%)',
            gridcolor:  isDark ? 'rgba(255,255,255,0.06)' : 'rgba(0,0,0,0.06)',
            zerolinecolor: isDark ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)',
            tickfont:   { size: 11 },
            color:      isDark ? '#a1a1aa' : '#71717a'
        },
        yaxis: {
            title:      'Dichte',
            gridcolor:  isDark ? 'rgba(255,255,255,0.06)' : 'rgba(0,0,0,0.06)',
            tickfont:   { size: 11 },
            color:      isDark ? '#a1a1aa' : '#71717a'
        },
        font: { family: 'DM Sans' }
    }, { responsive: true, displayModeBar: false });
}

// ------------------------------------------------------------
// J.3 Wahrscheinlichkeiten (Probability to be Best / vs. Baseline)
// ------------------------------------------------------------
/**
 * Rendert zwei nebeneinander liegende Panels:
 *  - Links:  "Probability to be Best" mit Fortschrittsbalken
 *  - Rechts: "Probability to beat Baseline"
 */
function renderProbabilities(container, stats, threshold) {
    const wrapper = document.createElement('div');
    wrapper.className = 'grid-2';

    // --- Links: Prob. to beat Baseline (kommt zuerst) ---
    const basePanel = createPanel('result-panel');
    basePanel.innerHTML = `
        <div class="section-title">
            Prob. to beat Baseline
            <span class="tooltip-wrap">
                <span class="tooltip-icon">i</span>
                <span class="tooltip-box">Wahrscheinlichkeit, dass diese Variante eine h√∂here wahre Conversion Rate als die Control-Gruppe hat. Gilt nur f√ºr Test-Varianten.</span>
            </span>
        </div>
    `;

    stats.forEach((s, i) => {
        const entry = document.createElement('div');
        entry.className = 'ci-entry';

        const inner = document.createElement('div');
        inner.style.width = '100%';

        const topRow = document.createElement('div');
        topRow.style.cssText = 'display:flex; justify-content:space-between; align-items:center; margin-bottom:6px;';

        const badge = document.createElement('span');
        badge.className = 'variant-badge';
        badge.style.background = hexToRgba(s.color, 0.10);
        badge.style.color = s.color;
        badge.textContent = s.label;   // textContent: sicher

        const barWrap = document.createElement('div');
        barWrap.className = 'prob-bar-wrap';
        const bar = document.createElement('div');
        bar.className = 'prob-bar';
        bar.style.background = s.color;
        barWrap.appendChild(bar);

        const subRow = document.createElement('div');
        subRow.style.cssText = 'margin-top:5px; font-size:12px; color:var(--text-muted);';

        if (i === 0) {
            entry.style.opacity = '0.45';
            const baselineLabel = document.createElement('span');
            baselineLabel.style.cssText = "font-family:'IBM Plex Mono',monospace; font-size:13px; color:var(--text-muted);";
            baselineLabel.textContent = 'Baseline';
            topRow.appendChild(badge);
            topRow.appendChild(baselineLabel);
            bar.style.width = '0%';
            subRow.textContent = '‚Äì';
        } else {
            const pct   = (s.probVsControl * 100).toFixed(1);
            const isWin = s.probVsControl >= threshold;
            const valEl = document.createElement('span');
            valEl.style.cssText = `font-family:'IBM Plex Mono',monospace; font-weight:600; font-size:14px; color:${isWin ? 'var(--success)' : 'var(--text-primary)'};`;
            valEl.textContent = `${pct}%${isWin ? ' ‚úì' : ''}`;
            topRow.appendChild(badge);
            topRow.appendChild(valEl);
            bar.style.width = `${pct}%`;
            subRow.textContent = 'Uplift: ';
            const upliftSpan = document.createElement('span');
            upliftSpan.innerHTML = formatUplift(s.uplift); // only toFixed numbers + CSS class
            subRow.appendChild(upliftSpan);
        }

        inner.appendChild(topRow);
        inner.appendChild(barWrap);
        inner.appendChild(subRow);
        entry.appendChild(inner);
        basePanel.appendChild(entry);
    });

    // Footer-Texte via DOM, kein innerHTML +=
    const baseFooter = document.createElement('div');
    baseFooter.className = 'small-text';
    baseFooter.textContent = 'Direkter Vergleich jeder Variante mit Control. Unabh√§ngig von anderen Varianten.';
    basePanel.appendChild(baseFooter);

    // --- Rechts: Probability to be Best ---
    const bestPanel = createPanel('result-panel');
    bestPanel.innerHTML = `
        <div class="section-title">
            Probability to be Best
            <span class="tooltip-wrap">
                <span class="tooltip-icon">i</span>
                <span class="tooltip-box">Wahrscheinlichkeit, dass diese Variante die h√∂chste wahre Conversion Rate unter allen getesteten Varianten hat.</span>
            </span>
        </div>
    `;

    stats.forEach((s) => {
        const pct = (s.probBest * 100).toFixed(1);
        const isAboveThreshold = s.probBest >= threshold;

        const entry = document.createElement('div');
        entry.className = 'ci-entry';

        const inner = document.createElement('div');
        inner.style.width = '100%';

        const topRow = document.createElement('div');
        topRow.style.cssText = 'display:flex; justify-content:space-between; align-items:center; margin-bottom:6px;';

        const badge = document.createElement('span');
        badge.className = 'variant-badge';
        badge.style.background = hexToRgba(s.color, 0.10);
        badge.style.color = s.color;
        badge.textContent = s.label;

        const valEl = document.createElement('span');
        valEl.style.cssText = `font-family:'IBM Plex Mono',monospace; font-weight:600; font-size:14px; color:${isAboveThreshold ? 'var(--success)' : 'var(--text-primary)'};`;
        valEl.textContent = `${pct}%${isAboveThreshold ? ' ‚úì' : ''}`;

        topRow.appendChild(badge);
        topRow.appendChild(valEl);

        const barWrap = document.createElement('div');
        barWrap.className = 'prob-bar-wrap';
        const bar = document.createElement('div');
        bar.className = 'prob-bar';
        bar.style.cssText = `width:${pct}%; background:${s.color};`;
        barWrap.appendChild(bar);

        const spacer = document.createElement('div');
        spacer.style.cssText = 'margin-top:5px; font-size:12px; color:var(--text-muted);';
        spacer.innerHTML = '&nbsp;';

        inner.appendChild(topRow);
        inner.appendChild(barWrap);
        inner.appendChild(spacer);
        entry.appendChild(inner);
        bestPanel.appendChild(entry);
    });

    const bestFooter = document.createElement('div');
    bestFooter.className = 'small-text';
    bestFooter.textContent = `Entscheidungsgrenze: ${(threshold*100).toFixed(0)}% ‚Äì Varianten mit ‚úì sind statistisch aussagekr√§ftig.`;
    bestPanel.appendChild(bestFooter);

    wrapper.appendChild(basePanel);
    wrapper.appendChild(bestPanel);
    container.appendChild(wrapper);
}

// ------------------------------------------------------------
// J.4 Credible Intervals (HDI-Tabelle)
// ------------------------------------------------------------
/**
 * Rendert eine Tabelle mit dem Highest Density Interval (HDI)
 * und dem Posterior-Median f√ºr jede Variante.
 */
function renderCredibleIntervals(container, stats, ciLevel) {
    const panel = createPanel('result-panel');
    panel.innerHTML = `
        <div class="section-title">
            ${(ciLevel * 100).toFixed(0)}% Credible Intervals (HDI)
            <span class="tooltip-wrap">
                <span class="tooltip-icon">i</span>
                <span class="tooltip-box">Das Highest Density Interval (HDI) ist das schmalste Intervall, das ${(ciLevel*100).toFixed(0)}% der Posterior-Wahrscheinlichkeit enth√§lt. Anders als ein frequentistisches KI kann man sagen: "Mit ${(ciLevel*100).toFixed(0)}% Wahrscheinlichkeit liegt die wahre CR in diesem Bereich."</span>
            </span>
        </div>
    `;

    stats.forEach((s) => {
        const entry = document.createElement('div');
        entry.className = 'ci-entry';

        // Linke Seite: Badge
        const leftEl = document.createElement('div');
        leftEl.className = 'ci-left';
        const badge = document.createElement('span');
        badge.className = 'variant-badge';
        badge.style.background = hexToRgba(s.color, 0.12);
        badge.style.color = s.color;
        badge.textContent = s.label;
        leftEl.appendChild(badge);

        // Rechte Seite: Werte-Grid
        const valuesEl = document.createElement('div');
        valuesEl.className = 'ci-values';
        [
            ['Untergrenze', `${(s.hdiLower * 100).toFixed(2)}%`],
            ['Median',      `${(s.median   * 100).toFixed(2)}%`],
            ['Obergrenze',  `${(s.hdiUpper * 100).toFixed(2)}%`],
            ['Breite',      `${((s.hdiUpper - s.hdiLower) * 100).toFixed(2)}pp`]
        ].forEach(([lbl, val]) => {
            const stat = document.createElement('div');
            stat.className = 'ci-stat';
            const statLbl = document.createElement('div');
            statLbl.className = 'ci-stat-label';
            statLbl.textContent = lbl;
            const statVal = document.createElement('div');
            statVal.className = 'ci-stat-value';
            statVal.textContent = val;
            stat.appendChild(statLbl);
            stat.appendChild(statVal);
            valuesEl.appendChild(stat);
        });

        entry.appendChild(leftEl);
        entry.appendChild(valuesEl);
        panel.appendChild(entry);
    });

    const ciFooter = document.createElement('div');
    ciFooter.className = 'small-text';
    ciFooter.innerHTML = '<b>Breite des HDI:</b> Ein schmales Intervall (wenige Prozentpunkte) bedeutet hohe Sicherheit √ºber die wahre CR. Ein breites Intervall signalisiert, dass mehr Daten ben√∂tigt werden.';
    panel.appendChild(ciFooter);
    container.appendChild(panel);
}

// ------------------------------------------------------------
// J.5 Expected Loss
// ------------------------------------------------------------
/**
 * Rendert den Expected Loss pro Variante.
 * Niedrige Werte = sicherere Entscheidung.
 */
function renderExpectedLoss(container, stats) {
    const panel = createPanel('result-panel');
    panel.innerHTML = `
        <div class="section-title">
            Expected Loss
            <span class="tooltip-wrap">
                <span class="tooltip-icon">i</span>
                <span class="tooltip-box">Durchschnittlicher entgangener Gewinn (in Prozentpunkten CR), wenn wir uns f√ºr diese Variante entscheiden, aber eine andere besser gewesen w√§re. Kombiniert Fehlerwahrscheinlichkeit und Fehlergr√∂√üe. Niedriger ist besser.</span>
            </span>
        </div>
    `;

    // Besten (niedrigsten) Loss identifizieren
    const minLoss = Math.min(...stats.map(s => s.loss));

    stats.forEach((s) => {
        const lossPct = (s.loss * 100).toFixed(3);
        const isBest  = s.loss === minLoss;
        const bg      = isBest
            ? 'background:var(--success-soft); border-color:rgba(34,197,94,0.2);'
            : '';

        const entry = document.createElement('div');
        entry.className = 'ci-entry';
        entry.style.cssText = bg;

        // Linke Seite: Badge + optionaler "Niedrigster Loss"-Hinweis
        const leftEl = document.createElement('div');
        leftEl.className = 'ci-left';

        const badge = document.createElement('span');
        badge.className = 'variant-badge';
        badge.style.background = hexToRgba(s.color, 0.12);
        badge.style.color = s.color;
        badge.textContent = s.label;          // textContent: kein XSS m√∂glich
        leftEl.appendChild(badge);

        if (isBest) {
            const bestTag = document.createElement('span');
            bestTag.style.cssText = 'font-size:12px;color:var(--success);font-weight:600;';
            bestTag.textContent = 'Niedrigster Loss ‚úì';
            leftEl.appendChild(bestTag);
        }

        const lossValueEl = document.createElement('div');
        lossValueEl.style.cssText = "font-family:'IBM Plex Mono',monospace; font-weight:600; font-size:16px;";
        lossValueEl.textContent = `${lossPct}%`;
        entry.appendChild(leftEl);
        entry.appendChild(lossValueEl);
        panel.appendChild(entry);
    });

    const lossFooter = document.createElement('div');
    lossFooter.className = 'small-text';
    lossFooter.innerHTML = '<b>Expected Loss</b> ber√ºcksichtigt sowohl die Wahrscheinlichkeit einer Fehlentscheidung als auch deren Ausma√ü. Er ist damit robuster als reine Gewinnwahrscheinlichkeiten. Ein Wert nahe 0% bedeutet, dass selbst im Fehlerfall kaum Performance verloren geht.';
    panel.appendChild(lossFooter);
    container.appendChild(panel);
}

// ------------------------------------------------------------
// J.6 Entscheidungsempfehlung
// ------------------------------------------------------------
/**
 * Rendert die finale Entscheidungsempfehlung.
 *
 * Stufen:
 *  ‚úÖ Gr√ºn   ‚Äì probBest >= threshold (Entscheidung m√∂glich)
 *  ‚è≥ Gelb   ‚Äì probBest >= 0.75 aber < threshold (Tendenz erkennbar)
 *  üîç Rot    ‚Äì probBest < 0.75 (keine klare Aussage)
 *
 * Hinweis: Der Expected Loss wird zus√§tzlich informativ angezeigt,
 * ist aber KEIN Gating-Kriterium f√ºr die Gr√ºn/Gelb-Einstufung.
 */
function renderDecision(container, stats, threshold) {
    const maxProbBest = Math.max(...stats.map(s => s.probBest));
    const winnerIdx   = stats.findIndex(s => s.probBest === maxProbBest);
    const winner      = stats[winnerIdx];
    const minLoss     = Math.min(...stats.map(s => s.loss));
    const threshPct   = (threshold * 100).toFixed(0);
    const probPct     = (maxProbBest * 100).toFixed(1);
    const lossPct     = (minLoss * 100).toFixed(3);

    let type, icon, titlePrefix, bodyParts;

    if (maxProbBest >= threshold) {
        type        = 'success';
        icon        = '‚úÖ';
        titlePrefix = 'Empfehlung: ';
        titleSuffix = ' einf√ºhren';
        bodyParts   = [
            { tag: 'b',    text: winner.label },
            { tag: null,   text: ` hat eine Gewinnwahrscheinlichkeit von ` },
            { tag: 'b',    text: `${probPct}%` },
            { tag: null,   text: ` und √ºberschreitet damit die Entscheidungsgrenze von ${threshPct}%.` },
            { tag: 'br2' },
            { tag: null,   text: `Expected Loss: ` },
            { tag: 'b',    text: `${lossPct}%` },
            { tag: null,   text: minLoss < 0.0005 ? ' ‚Äì vernachl√§ssigbar.' : ' ‚Äì bitte einsch√§tzen, ob dieser Wert akzeptabel ist.' },
            { tag: 'br2' },
            { tag: null,   text: 'Relativer Uplift vs. Control: ' },
            { tag: 'uplift', value: winner.uplift }
        ];
    } else if (maxProbBest >= 0.75) {
        type        = 'warning';
        icon        = '‚è≥';
        titlePrefix = 'Tendenz: ';
        titleSuffix = ' f√ºhrt ‚Äì Test fortsetzen';
        bodyParts   = [
            { tag: 'b',   text: winner.label },
            { tag: null,  text: ` liegt vorne mit ` },
            { tag: 'b',   text: `${probPct}%` },
            { tag: null,  text: ` Gewinnwahrscheinlichkeit, hat aber die Entscheidungsgrenze von ${threshPct}% noch nicht erreicht (Differenz: ${(threshold * 100 - maxProbBest * 100).toFixed(1)} Prozentpunkte).` },
            { tag: 'br2' },
            { tag: null,  text: 'Expected Loss: ' },
            { tag: 'b',   text: `${lossPct}%` },
            { tag: 'br2' },
            { tag: null,  text: 'Empfehlung: Weitere Daten sammeln.' }
        ];
    } else {
        type        = 'danger';
        icon        = 'üîç';
        titlePrefix = '';
        titleSuffix = '';
        bodyParts   = [
            { tag: null,  text: `Keine Variante √ºberschreitet die Entscheidungsgrenze von ${threshPct}%. Die h√∂chste Gewinnwahrscheinlichkeit liegt bei ${probPct}%.` },
            { tag: 'br2' },
            { tag: null,  text: 'Expected Loss: ' },
            { tag: 'b',   text: `${lossPct}%` },
            { tag: 'br2' },
            { tag: null,  text: 'Empfehlung: Mehr Daten sammeln oder den Test neu aufsetzen.' }
        ];
    }

    const box = document.createElement('div');
    box.className = `decision-box ${type} result-panel`;

    // Titel ‚Äì Label via textContent, kein innerHTML
    const titleEl = document.createElement('div');
    titleEl.className = 'decision-title';
    titleEl.appendChild(document.createTextNode(`${icon} ${titlePrefix}`));
    if (titlePrefix) {
        const labelSpan = document.createElement('span');
        labelSpan.textContent = winner.label;
        titleEl.appendChild(labelSpan);
        titleEl.appendChild(document.createTextNode(titleSuffix));
    } else {
        titleEl.appendChild(document.createTextNode('Keine klare Entscheidung m√∂glich'));
    }

    // Body ‚Äì Textknoten und <b>-Tags, kein Nutzer-HTML
    const bodyEl = document.createElement('div');
    bodyEl.style.cssText = 'color:var(--text-secondary); line-height:1.7;';
    bodyParts.forEach(part => {
        if (part.tag === 'br2') {
            bodyEl.appendChild(document.createElement('br'));
            bodyEl.appendChild(document.createElement('br'));
        } else if (part.tag === 'b') {
            const b = document.createElement('b');
            b.textContent = part.text;
            bodyEl.appendChild(b);
        } else if (part.tag === 'uplift') {
            // formatUplift produziert nur toFixed()-Zahlen + CSS-Klassenname, kein Nutzereingabe
            const span = document.createElement('span');
            span.innerHTML = formatUplift(part.value);
            bodyEl.appendChild(span);
        } else {
            bodyEl.appendChild(document.createTextNode(part.text));
        }
    });

    box.appendChild(titleEl);
    box.appendChild(bodyEl);
    container.appendChild(box);
}


// ============================================================
// K. CSV-EXPORT
// ============================================================

/**
 * Exportiert alle Analyse-Boxen als CSV im deutschen Format:
 *  ‚Äì Semikolon als Spaltentrennzeichen (Excel-DE-Standard)
 *  ‚Äì Komma als Dezimaltrennzeichen
 */
function exportCSV() {
    if (!lastResults) return;

    const { boxResults, ciLevel } = lastResults;
    const ci  = (ciLevel * 100).toFixed(0);
    const sep = ';';
    const de  = v => String(v).replace('.', ',');

    // RFC 4180: Felder mit Semikolon, Anf√ºhrungszeichen oder Zeilenumbruch in Anf√ºhrungszeichen einschlie√üen
    const csvCell = v => {
        const s = String(v);
        return (s.includes(';') || s.includes('"') || s.includes('\n') || s.includes('\r'))
            ? `"${s.replace(/"/g, '""')}"` : s;
    };

    const headers = [
        'Analyse', 'Variante', 'Besucher', 'Conversions', 'Conversion Rate (%)',
        'Relativer Uplift (%)', 'Prob. to beat Baseline (%)', 'Prob. to be Best (%)',
        `HDI Lower ${ci}% (%)`, 'Median (%)', `HDI Upper ${ci}% (%)`,
        'Expected Loss (%)'
    ];

    const sections = boxResults.map(box => {
        const dataRows = box.stats.map(s => [
            csvCell(box.title),
            csvCell(s.label),
            s.n,
            s.c,
            de((s.rate * 100).toFixed(3)),
            s.uplift !== null ? de((s.uplift * 100).toFixed(2)) : 'Baseline',
            s.probVsControl !== null ? de((s.probVsControl * 100).toFixed(2)) : 'Baseline',
            de((s.probBest * 100).toFixed(2)),
            de((s.hdiLower * 100).toFixed(3)),
            de((s.median * 100).toFixed(3)),
            de((s.hdiUpper * 100).toFixed(3)),
            de((s.loss * 100).toFixed(4))
        ]);
        return [headers, ...dataRows].map(r => r.join(sep)).join('\n');
    });

    const bom = '\uFEFF';
    const csv = bom + sections.join('\n\n');
    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
    const url  = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href     = url;
    link.download = `ab_test_${new Date().toISOString().slice(0, 10)}.csv`;
    link.click();
    URL.revokeObjectURL(url);
}


// ============================================================
// HILFSFUNKTIONEN
// ============================================================

/**
 * Escapet einen String f√ºr sicheres Einf√ºgen in innerHTML.
 *
 * Warum n√∂tig: Varianten-Namen und Box-Titel werden vom Nutzer
 * frei eingegeben und anschlie√üend via Template-Literal in
 * innerHTML geschrieben. Ohne Escaping k√∂nnte ein Name wie
 *   <img src=x onerror=alert(1)>
 * als HTML interpretiert werden (Stored-XSS innerhalb der Seite).
 *
 * Diese Funktion ersetzt die f√ºnf HTML-Sonderzeichen durch ihre
 * Entit√§ten, bevor der String in den DOM gelangt.
 *
 * @param {string} str - Beliebiger Nutzer-String
 * @returns {string}   - HTML-sicherer String
 */
function escapeHTML(str) {
    return String(str)
        .replace(/&/g,  '&amp;')
        .replace(/</g,  '&lt;')
        .replace(/>/g,  '&gt;')
        .replace(/"/g,  '&quot;')
        .replace(/'/g,  '&#039;');
}

/**
 * @param {string} extraClass - Optional weitere CSS-Klasse
 * @returns {HTMLElement}
 */
function createPanel(extraClass = '') {
    const el = document.createElement('div');
    el.className = `glass result-panel ${extraClass}`.trim();
    return el;
}

/**
 * Wandelt einen Hex-Farbcode in rgba() um.
 *
 * @param {string} hex   - z. B. '#5b6cf9'
 * @param {number} alpha - Transparenz [0,1]
 * @returns {string}     - z. B. 'rgba(91,108,249,0.12)'
 */
function hexToRgba(hex, alpha) {
    // Nur valide 6-stellige Hex-Farben akzeptieren
    if (!/^#[0-9a-fA-F]{6}$/.test(hex)) return `rgba(0,0,0,${alpha})`;
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);
    return `rgba(${r},${g},${b},${alpha})`;
}

/**
 * Formatiert einen relativen Uplift-Wert als farbigen Chip-String.
 *
 * @param {number|null} uplift - Dezimalzahl, z. B. 0.12 f√ºr +12%
 * @returns {string} HTML-String
 */
function formatUplift(uplift) {
    if (uplift === null) return '‚Äì';
    const pct = (uplift * 100).toFixed(1);
    const cls = uplift > 0 ? 'uplift-pos' : uplift < 0 ? 'uplift-neg' : 'uplift-neu';
    const sign = uplift > 0 ? '+' : '';
    return `<span class="uplift-chip ${cls}">${sign}${pct}%</span>`;
}

</script>
</body>
</html>