<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<title>Bayesian A/B Testing Dashboard</title>
<script defer src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>

<style>
:root {
    --bg-light: linear-gradient(135deg,#e9f1ff,#f7faff);
    --bg-dark: linear-gradient(135deg,#1c1c1e,#2c2c2e);
    --text-light:#1d1d1f;
    --text-dark:#f5f5f7;
}

body {
    font-family:-apple-system,BlinkMacSystemFont,sans-serif;
    margin:0;
    padding:60px;
    transition:all 0.4s ease;
}

body.light {
    background:var(--bg-light);
    color:var(--text-light);
}

body.dark {
    background:var(--bg-dark);
    color:var(--text-dark);
}

.glass {
    background:rgba(255,255,255,0.55);
    backdrop-filter:blur(30px);
    -webkit-backdrop-filter:blur(30px);
    border-radius:26px;
    padding:35px;
    margin-bottom:40px;
    box-shadow:0 8px 40px rgba(0,0,0,0.12);
    transition:all 0.4s ease;
}

body.dark .glass {
    background:rgba(50,50,55,0.45);
}

h1 {
    font-weight:600;
    margin-bottom:50px;
}

.variant-row {
    display:flex;
    align-items:center;
    gap:15px;
    margin-bottom:16px;
}

.variant-label {
    width:120px;
    font-weight:500;
}

input {
    padding:9px;
    border-radius:14px;
    border:none;
    background:rgba(255,255,255,0.7);
    width:110px;
}

body.dark input {
    background:#50505599;
    color:white;
}

button {
    background:linear-gradient(135deg,#3C414B,#3C414B);
    border:none;
    color:white;
    padding:12px 22px;
    border-radius:18px;
    cursor:pointer;
    transition:all 0.25s ease;
}

button:hover {
    transform:translateY(-2px);
    box-shadow:0 8px 20px #646973;
}

.toggle {
    position:absolute;
    top:30px;
    right:40px;
}

.kpi-box {
    padding:28px;
    border-radius:26px;
    font-size:18px;
}

.success {background:rgba(52,199,89,0.15);}
.warning {background:rgba(255,204,0,0.2);}
.danger {background:rgba(255,59,48,0.15);}

.ci-entry {
    margin-bottom:14px;
    font-size:17px;
}

.small-text {
    font-size:14px;
    opacity:0.7;
    margin-top:15px;
}
</style>
</head>

<body class="light">

<button class="toggle" onclick="toggleMode()">üåó Dark Mode</button>

<h1>Bayesian A/B Testing Dashboard</h1>

<div class="glass">
<h3>Varianten</h3>
<div id="variants"></div>
<button onclick="addVariant()">+ Variante hinzuf√ºgen</button>

<details style="margin-top:25px;">
    <summary style="cursor:pointer;font-weight:500;">Advanced Settings</summary>
    <div style="margin-top:15px;">
        Prior Œ±: <input type="number" id="priorA" value="1">
        Prior Œ≤: <input type="number" id="priorB" value="1">
        Entscheidungsgrenze (%): <input type="number" id="threshold" value="95">
    </div>
</details>
</div>

<div class="glass">
<button onclick="runTest()">Analyse starten</button>
</div>

<div id="results"></div>

<script>
    
let variantCounter = 0;

function toggleMode(){
    document.body.classList.toggle("dark");
    document.body.classList.toggle("light");
}

function initializeVariants(){
    variantCounter = 0;
    document.getElementById("variants").innerHTML = "";
    addVariant(true);   // Control
    addVariant(false);  // Variante 1
}

function addVariant(isControl = false){
    const row = document.createElement("div");
    row.className = "variant-row";

    const nonControlCount = document.querySelectorAll(".variant-row").length;
    const label = isControl ? "Control" : `Variante ${nonControlCount}`;

    row.innerHTML = `
        <span class="variant-label">${label}</span>
        Besucher:<input type="number" value="1000">
        Conversions:<input type="number" value="100">
        ${!isControl ? `<button onclick="this.parentElement.remove()">‚úï</button>` : ""}
    `;
    document.getElementById("variants").appendChild(row);
}

function normalSample(){
    let u = 0, v = 0;
    while(u === 0) u = Math.random();
    while(v === 0) v = Math.random();
    return Math.sqrt(-2 * Math.log(u)) * Math.cos(2 * Math.PI * v);
}

function gammaSample(s){
    const d = s - 1/3;
    const c = 1 / Math.sqrt(9 * d);
    while(true){
        let x = normalSample();
        let v = Math.pow(1 + c * x, 3);
        if(v > 0){
            let u = Math.random();
            if(u < 1 - 0.0331 * Math.pow(x, 4) || Math.log(u) < 0.5 * x * x + d * (1 - v + Math.log(v))){
                return d * v;
            }
        }
    }
}

function betaSample(a, b){
    const x = gammaSample(a);
    const y = gammaSample(b);
    return x / (x + y);
}

function percentile(arr, p){
    const sorted = [...arr].sort((a, b) => a - b);
    return sorted[Math.floor(p * sorted.length)];
}

function runTest(){
    const priorA    = parseFloat(document.getElementById("priorA").value);
    const priorB    = parseFloat(document.getElementById("priorB").value);
    const threshold = parseFloat(document.getElementById("threshold").value) / 100;
    const numSamples = 100000;

    const rows = document.querySelectorAll(".variant-row");
    const variants = [];
    rows.forEach((row, i) => {
        const inputs = row.querySelectorAll("input");
        const n = parseInt(inputs[0].value);
        const c = parseInt(inputs[1].value);
        variants.push({
            label: i === 0 ? "Control" : `Variante ${i}`,
            alpha: priorA + c,
            beta:  priorB + n - c
        });
    });

    const posteriors = variants.map(v => {
        const arr = new Float32Array(numSamples);
        for(let i = 0; i < numSamples; i++){
            arr[i] = betaSample(v.alpha, v.beta);
        }
        return arr;
    });

    const bestCounts = Array(variants.length).fill(0);
    for(let i = 0; i < numSamples; i++){
        const vals = posteriors.map(p => p[i]);
        bestCounts[vals.indexOf(Math.max(...vals))]++;
    }

    const probs = bestCounts.map(c => c / numSamples);
    renderResults(variants, posteriors, probs, threshold, numSamples);
}

function kernelDensityEstimator(sample, bandwidth = 0.15){
    const points = 200;
    const min = Math.min(...sample);
    const max = Math.max(...sample);
    const step = (max - min) / points;

    const xs = [];
    const ys = [];

    for(let i = 0; i <= points; i++){
        const x = min + i * step;
        xs.push(x);

        let sum = 0;
        for(let j = 0; j < sample.length; j++){
            const u = (x - sample[j]) / bandwidth;
            sum += Math.exp(-0.5 * u * u);
        }
        ys.push(sum / (sample.length * bandwidth * Math.sqrt(2 * Math.PI)));
    }

    return { xs, ys };
}

function renderResults(variants, posteriors, probs, threshold, numSamples){

    const results = document.getElementById("results");
    results.innerHTML = "";

    const distBox = document.createElement("div");
    distBox.className = "glass";
    results.appendChild(distBox);

    if(typeof Plotly === "undefined"){
        alert("Plotly konnte nicht geladen werden.");
        return;
    }

    // Posterior Density Curves
    const densityTraces = posteriors.map((p, i) => {
        const samplePercent = Array.from(p).map(v => v * 100);
        const density = kernelDensityEstimator(samplePercent, 0.15);

        return {
            x: density.xs,
            y: density.ys,
            mode: "lines",
            name: variants[i].label,
            line: { width: 3 },
            fill: "tozeroy",
            opacity: 0.4
        };
    });

    Plotly.newPlot(distBox, densityTraces, {
        title: "Posterior Density Curves",
        paper_bgcolor: "rgba(0,0,0,0)",
        plot_bgcolor: "rgba(0,0,0,0)",
        xaxis: { title: "Conversion Rate (%)" },
        yaxis: { title: "Density" }
    });

    // Probability to beat Baseline
    const baselineBox = document.createElement("div");
    baselineBox.className = "glass";
    baselineBox.innerHTML = "<h3>Probability to beat Baseline</h3>";

    const controlPosterior = posteriors[0];

    for(let i = 1; i < posteriors.length; i++){
        let betterCount = 0;
        for(let j = 0; j < numSamples; j++){
            if(posteriors[i][j] > controlPosterior[j]) betterCount++;
        }
        const probability = (betterCount / numSamples * 100).toFixed(2);

        baselineBox.innerHTML += `
            <div class="ci-entry">
                <strong>${variants[i].label}</strong>: ${probability}% Wahrscheinlichkeit besser als Control
            </div>
        `;
    }

    baselineBox.innerHTML += `
        <div class="small-text">
        Gibt die posterior Wahrscheinlichkeit an, dass die jeweilige Variante eine h√∂here Conversion Rate
        als die Control-Variante besitzt.
        </div>
    `;
    results.appendChild(baselineBox);

    // Probability to be Best
    const bestBox = document.createElement("div");
    bestBox.className = "glass";
    bestBox.innerHTML = "<h3>Probability to be Best</h3>";

    variants.forEach((v, i) => {
        const probability = (probs[i] * 100).toFixed(2);
        bestBox.innerHTML += `
            <div class="ci-entry">
                <strong>${v.label}</strong>: ${probability}%
            </div>
        `;
    });

    bestBox.innerHTML += `
        <div class="small-text">
        Posterior Wahrscheinlichkeit, dass die jeweilige Variante die h√∂chste Conversion Rate
        unter allen getesteten Varianten besitzt.
        </div>
    `;
    results.appendChild(bestBox);

    // Expected Loss
    const lossBox = document.createElement("div");
    lossBox.className = "glass";
    lossBox.innerHTML = "<h3>Expected Loss</h3>";

    const losses = variants.map((v, i) => {
        let lossSum = 0;
        for(let j = 0; j < numSamples; j++){
            let bestVal = -Infinity;
            for(let k = 0; k < posteriors.length; k++){
                if(posteriors[k][j] > bestVal) bestVal = posteriors[k][j];
            }
            lossSum += (bestVal - posteriors[i][j]);
        }
        return lossSum / numSamples;
    });

    losses.forEach((loss, i) => {
        const expectedLoss = (loss * 100).toFixed(3);
        const bg = loss < 0.0001
            ? "rgba(52,199,89,0.15)"
            : "rgba(255,149,0,0.15)";

        lossBox.innerHTML += `
            <div class="ci-entry" style="padding:12px;border-radius:14px;background:${bg};">
                <strong>${variants[i].label}</strong>: ${expectedLoss}% erwarteter Verlust
            </div>
        `;
    });

    lossBox.innerHTML += `
    <div class="small-text">
    <b>Was bedeutet Expected Loss?</b><br><br>
    Der Expected Loss zeigt, wie viel Conversion-Rate wir im Durchschnitt verlieren w√ºrden,
    wenn wir diese Variante ausw√§hlen ‚Äì obwohl in Wirklichkeit eine andere Variante besser ist.<br><br>
    Es werden also zwei Dinge kombiniert:<br>
    ‚Ä¢ Wie wahrscheinlich es ist, dass wir mit unserer Entscheidung falsch liegen<br>
    ‚Ä¢ Wie gro√ü der Unterschied zur tats√§chlich besten Variante w√§re<br><br>
    Ein Wert von <b>0%</b> bedeutet: Diese Variante ist in fast allen Simulationen die beste Wahl.<br>
    Ein h√∂herer Wert bedeutet: Falls wir uns f√ºr diese Variante entscheiden und eine andere sich als besser erweist,
    zeigt dieser Wert, wie gro√ü der durchschnittliche Performance-Nachteil w√§re.<br><br>
    üëâ Niedriger ist besser. Die sicherste Entscheidung hat den kleinsten Expected Loss.
    </div>
    `;
    results.appendChild(lossBox);

    // Ergebniszusammenfassung
    const decision = document.createElement("div");
    decision.className = "glass kpi-box";

    const maxProb     = Math.max(...probs);
    const winnerIndex = probs.indexOf(maxProb);
    const minLoss     = Math.min(...losses);
    const safestIndex = losses.indexOf(minLoss);

    if(maxProb > threshold && minLoss < 0.0001){
        decision.classList.add("success");
        decision.innerHTML = `
        <strong>Empfehlung: ${variants[winnerIndex].label}</strong><br><br>
        Diese Variante hat eine Gewinnwahrscheinlichkeit von ${(maxProb * 100).toFixed(1)}%
        (√ºber der festgelegten Entscheidungsgrenze von ${(threshold * 100).toFixed(0)}%).<br><br>
        Gleichzeitig ist ihr Expected Loss mit ${(minLoss * 100).toFixed(3)}% sehr gering.
        Das bedeutet: Selbst wenn wir uns irren sollten, w√§re der durchschnittliche Verlust minimal.<br><br>
        üëâ Die Daten sprechen klar f√ºr diese Variante.
        `;
    } else if(maxProb > 0.75){
        decision.classList.add("warning");
        decision.innerHTML = `
        <strong>Zwischenergebnis: ${variants[winnerIndex].label} f√ºhrt</strong><br><br>
        Die Gewinnwahrscheinlichkeit liegt bei ${(maxProb * 100).toFixed(1)}%,
        erreicht jedoch noch nicht die Entscheidungsgrenze von ${(threshold * 100).toFixed(0)}%.<br><br>
        Der Expected Loss betr√§gt ${(minLoss * 100).toFixed(3)}%.
        Es besteht also noch ein gewisses Entscheidungsrisiko.<br><br>
        üëâ Empfehlung: Test weiterlaufen lassen.
        `;
    } else {
        decision.classList.add("danger");
        decision.innerHTML = `
        <strong>Keine klare Entscheidung m√∂glich</strong><br><br>
        Keine Variante erreicht die notwendige Gewinnwahrscheinlichkeit
        von ${(threshold * 100).toFixed(0)}%.<br><br>
        Der aktuell geringste Expected Loss liegt bei ${(minLoss * 100).toFixed(3)}%,
        was bedeutet, dass noch Unsicherheit √ºber die tats√§chlich beste Variante besteht.<br><br>
        üëâ Empfehlung: Weitere Daten sammeln.
        `;
    }

    results.appendChild(decision);
}

initializeVariants();
</script>

</body>
</html>